{"ast":null,"code":"/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\nimport { visit } from '../language/visitor';\n/**\r\n * separateOperations accepts a single AST document which may contain many\r\n * operations and fragments and returns a collection of AST documents each of\r\n * which contains a single operation as well the fragment definitions it\r\n * refers to.\r\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var fragments = Object.create(null);\n  var positions = new Map();\n  var depGraph = Object.create(null);\n  var fromName;\n  var idx = 0; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n      positions.set(node, idx++);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n      fragments[fromName] = node;\n      positions.set(node, idx++);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  for (var _i = 0; _i < operations.length; _i++) {\n    var operation = operations[_i];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    var definitions = [operation];\n\n    var _arr = Object.keys(dependencies);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var name = _arr[_i2];\n      definitions.push(fragments[name]);\n    }\n\n    definitions.sort(function (n1, n2) {\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\n    });\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: definitions\n    };\n  }\n\n  return separatedDocumentASTs;\n} // Provides the empty string for anonymous operations.\n\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    var _arr2 = Object.keys(immediateDeps);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var toName = _arr2[_i3];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/separateOperations.mjs"],"names":["visit","separateOperations","documentAST","operations","fragments","Object","create","positions","Map","depGraph","fromName","idx","OperationDefinition","node","opName","push","set","FragmentDefinition","name","value","FragmentSpread","toName","separatedDocumentASTs","_i","length","operation","operationName","dependencies","collectTransitiveDependencies","definitions","_arr","keys","_i2","sort","n1","n2","get","kind","collected","immediateDeps","_arr2","_i3"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,KAAT,QAAsB,qBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA4BC,WAA5B,EAAyC;AAC9C,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB;AACA,MAAIC,SAAS,GAAG,IAAIC,GAAJ,EAAhB;AACA,MAAIC,QAAQ,GAAGJ,MAAM,CAACC,MAAP,CAAc,IAAd,CAAf;AACA,MAAII,QAAJ;AACA,MAAIC,GAAG,GAAG,CAAV,CAN8C,CAMjC;;AAEbX,EAAAA,KAAK,CAACE,WAAD,EAAc;AACjBU,IAAAA,mBAAmB,EAAE,SAASA,mBAAT,CAA6BC,IAA7B,EAAmC;AACtDH,MAAAA,QAAQ,GAAGI,MAAM,CAACD,IAAD,CAAjB;AACAV,MAAAA,UAAU,CAACY,IAAX,CAAgBF,IAAhB;AACAN,MAAAA,SAAS,CAACS,GAAV,CAAcH,IAAd,EAAoBF,GAAG,EAAvB;AACD,KALgB;AAMjBM,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BJ,IAA5B,EAAkC;AACpDH,MAAAA,QAAQ,GAAGG,IAAI,CAACK,IAAL,CAAUC,KAArB;AACAf,MAAAA,SAAS,CAACM,QAAD,CAAT,GAAsBG,IAAtB;AACAN,MAAAA,SAAS,CAACS,GAAV,CAAcH,IAAd,EAAoBF,GAAG,EAAvB;AACD,KAVgB;AAWjBS,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBP,IAAxB,EAA8B;AAC5C,UAAIQ,MAAM,GAAGR,IAAI,CAACK,IAAL,CAAUC,KAAvB;AACA,OAACV,QAAQ,CAACC,QAAD,CAAR,KAAuBD,QAAQ,CAACC,QAAD,CAAR,GAAqBL,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5C,CAAD,EAAmEe,MAAnE,IAA6E,IAA7E;AACD;AAdgB,GAAd,CAAL,CAR8C,CAuB1C;AACJ;;AAEA,MAAIC,qBAAqB,GAAGjB,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;;AAEA,OAAK,IAAIiB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGpB,UAAU,CAACqB,MAAjC,EAAyCD,EAAE,EAA3C,EAA+C;AAC7C,QAAIE,SAAS,GAAGtB,UAAU,CAACoB,EAAD,CAA1B;AACA,QAAIG,aAAa,GAAGZ,MAAM,CAACW,SAAD,CAA1B;AACA,QAAIE,YAAY,GAAGtB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAnB;AACAsB,IAAAA,6BAA6B,CAACD,YAAD,EAAelB,QAAf,EAAyBiB,aAAzB,CAA7B,CAJ6C,CAIyB;AACtE;;AAEA,QAAIG,WAAW,GAAG,CAACJ,SAAD,CAAlB;;AAEA,QAAIK,IAAI,GAAGzB,MAAM,CAAC0B,IAAP,CAAYJ,YAAZ,CAAX;;AAEA,SAAK,IAAIK,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,IAAI,CAACN,MAA7B,EAAqCQ,GAAG,EAAxC,EAA4C;AAC1C,UAAId,IAAI,GAAGY,IAAI,CAACE,GAAD,CAAf;AACAH,MAAAA,WAAW,CAACd,IAAZ,CAAiBX,SAAS,CAACc,IAAD,CAA1B;AACD;;AAEDW,IAAAA,WAAW,CAACI,IAAZ,CAAiB,UAAUC,EAAV,EAAcC,EAAd,EAAkB;AACjC,aAAO,CAAC5B,SAAS,CAAC6B,GAAV,CAAcF,EAAd,KAAqB,CAAtB,KAA4B3B,SAAS,CAAC6B,GAAV,CAAcD,EAAd,KAAqB,CAAjD,CAAP;AACD,KAFD;AAGAb,IAAAA,qBAAqB,CAACI,aAAD,CAArB,GAAuC;AACrCW,MAAAA,IAAI,EAAE,UAD+B;AAErCR,MAAAA,WAAW,EAAEA;AAFwB,KAAvC;AAID;;AAED,SAAOP,qBAAP;AACD,C,CAED;;AACA,SAASR,MAAT,CAAgBW,SAAhB,EAA2B;AACzB,SAAOA,SAAS,CAACP,IAAV,GAAiBO,SAAS,CAACP,IAAV,CAAeC,KAAhC,GAAwC,EAA/C;AACD,C,CAAC;AACF;;;AAGA,SAASS,6BAAT,CAAuCU,SAAvC,EAAkD7B,QAAlD,EAA4DC,QAA5D,EAAsE;AACpE,MAAI6B,aAAa,GAAG9B,QAAQ,CAACC,QAAD,CAA5B;;AAEA,MAAI6B,aAAJ,EAAmB;AACjB,QAAIC,KAAK,GAAGnC,MAAM,CAAC0B,IAAP,CAAYQ,aAAZ,CAAZ;;AAEA,SAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,KAAK,CAAChB,MAA9B,EAAsCiB,GAAG,EAAzC,EAA6C;AAC3C,UAAIpB,MAAM,GAAGmB,KAAK,CAACC,GAAD,CAAlB;;AAEA,UAAI,CAACH,SAAS,CAACjB,MAAD,CAAd,EAAwB;AACtBiB,QAAAA,SAAS,CAACjB,MAAD,CAAT,GAAoB,IAApB;AACAO,QAAAA,6BAA6B,CAACU,SAAD,EAAY7B,QAAZ,EAAsBY,MAAtB,CAA7B;AACD;AACF;AACF;AACF","sourcesContent":["/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\r\nimport { visit } from '../language/visitor';\r\n\r\n/**\r\n * separateOperations accepts a single AST document which may contain many\r\n * operations and fragments and returns a collection of AST documents each of\r\n * which contains a single operation as well the fragment definitions it\r\n * refers to.\r\n */\r\nexport function separateOperations(documentAST) {\r\n  var operations = [];\r\n  var fragments = Object.create(null);\r\n  var positions = new Map();\r\n  var depGraph = Object.create(null);\r\n  var fromName;\r\n  var idx = 0; // Populate metadata and build a dependency graph.\r\n\r\n  visit(documentAST, {\r\n    OperationDefinition: function OperationDefinition(node) {\r\n      fromName = opName(node);\r\n      operations.push(node);\r\n      positions.set(node, idx++);\r\n    },\r\n    FragmentDefinition: function FragmentDefinition(node) {\r\n      fromName = node.name.value;\r\n      fragments[fromName] = node;\r\n      positions.set(node, idx++);\r\n    },\r\n    FragmentSpread: function FragmentSpread(node) {\r\n      var toName = node.name.value;\r\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\r\n    }\r\n  }); // For each operation, produce a new synthesized AST which includes only what\r\n  // is necessary for completing that operation.\r\n\r\n  var separatedDocumentASTs = Object.create(null);\r\n\r\n  for (var _i = 0; _i < operations.length; _i++) {\r\n    var operation = operations[_i];\r\n    var operationName = opName(operation);\r\n    var dependencies = Object.create(null);\r\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\r\n    // to retain the same order as the original document.\r\n\r\n    var definitions = [operation];\r\n\r\n    var _arr = Object.keys(dependencies);\r\n\r\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\r\n      var name = _arr[_i2];\r\n      definitions.push(fragments[name]);\r\n    }\r\n\r\n    definitions.sort(function (n1, n2) {\r\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\r\n    });\r\n    separatedDocumentASTs[operationName] = {\r\n      kind: 'Document',\r\n      definitions: definitions\r\n    };\r\n  }\r\n\r\n  return separatedDocumentASTs;\r\n}\r\n\r\n// Provides the empty string for anonymous operations.\r\nfunction opName(operation) {\r\n  return operation.name ? operation.name.value : '';\r\n} // From a dependency graph, collects a list of transitive dependencies by\r\n// recursing through a dependency graph.\r\n\r\n\r\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\r\n  var immediateDeps = depGraph[fromName];\r\n\r\n  if (immediateDeps) {\r\n    var _arr2 = Object.keys(immediateDeps);\r\n\r\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\r\n      var toName = _arr2[_i3];\r\n\r\n      if (!collected[toName]) {\r\n        collected[toName] = true;\r\n        collectTransitiveDependencies(collected, depGraph, toName);\r\n      }\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}