{"ast":null,"code":"/**\r\n * Copyright (c) 2016, Lee Byron\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n * @ignore\r\n */\n\n/**\r\n * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\r\n * is a *protocol* which describes a standard way to produce a sequence of\r\n * values, typically the values of the Iterable represented by this Iterator.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterator\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}\r\n */\n\n/**\r\n * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * their iteration behavior, such as what values are looped over in a\r\n * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\r\n * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)\r\n * implement the Iterable protocol, including `Array` and `Map`.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterable\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}\r\n */\n// In ES2015 environments, Symbol exists\nvar SYMBOL\n/*: any */\n= typeof Symbol === 'function' ? Symbol : void 0; // In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\n\nvar SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator;\n/**\r\n * A property name to be used as the name of an Iterable's method responsible\r\n * for producing an Iterator, referred to as `@@iterator`. Typically represents\r\n * the value `Symbol.iterator` but falls back to the string `\"@@iterator\"` when\r\n * `Symbol.iterator` is not defined.\r\n *\r\n * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,\r\n * but do not use it for accessing existing Iterables, instead use\r\n * {@link getIterator} or {@link isIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$iterator = require('iterall').$$iterator\r\n *\r\n * function Counter (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Counter.prototype[$$iterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       if (this.num >= this.to) {\r\n *         return { value: undefined, done: true }\r\n *       }\r\n *       return { value: this.num++, done: false }\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var counter = new Counter(3)\r\n * for (var number of counter) {\r\n *   console.log(number) // 0 ... 1 ... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\n\n/*:: declare export var $$iterator: '@@iterator'; */\n\nexport var $$iterator = SYMBOL_ITERATOR || '@@iterator';\n/**\r\n * Returns true if the provided object implements the Iterator protocol via\r\n * either implementing a `Symbol.iterator` or `\"@@iterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isIterable = require('iterall').isIterable\r\n * isIterable([ 1, 2, 3 ]) // true\r\n * isIterable('ABC') // true\r\n * isIterable({ length: 1, 0: 'Alpha' }) // false\r\n * isIterable({ key: 'value' }) // false\r\n * isIterable(new Map()) // true\r\n *\r\n * @param obj\r\n *   A value which might implement the Iterable protocol.\r\n * @return {boolean} true if Iterable.\r\n */\n\n/*:: declare export function isIterable(obj: any): boolean; */\n\nexport function isIterable(obj) {\n  return !!getIteratorMethod(obj);\n}\n/**\r\n * Returns true if the provided object implements the Array-like protocol via\r\n * defining a positive-integer `length` property.\r\n *\r\n * @example\r\n *\r\n * var isArrayLike = require('iterall').isArrayLike\r\n * isArrayLike([ 1, 2, 3 ]) // true\r\n * isArrayLike('ABC') // true\r\n * isArrayLike({ length: 1, 0: 'Alpha' }) // true\r\n * isArrayLike({ key: 'value' }) // false\r\n * isArrayLike(new Map()) // false\r\n *\r\n * @param obj\r\n *   A value which might implement the Array-like protocol.\r\n * @return {boolean} true if Array-like.\r\n */\n\n/*:: declare export function isArrayLike(obj: any): boolean; */\n\nexport function isArrayLike(obj) {\n  var length = obj != null && obj.length;\n  return typeof length === 'number' && length >= 0 && length % 1 === 0;\n}\n/**\r\n * Returns true if the provided object is an Object (i.e. not a string literal)\r\n * and is either Iterable or Array-like.\r\n *\r\n * This may be used in place of [Array.isArray()][isArray] to determine if an\r\n * object should be iterated-over. It always excludes string literals and\r\n * includes Arrays (regardless of if it is Iterable). It also includes other\r\n * Array-like objects such as NodeList, TypedArray, and Buffer.\r\n *\r\n * @example\r\n *\r\n * var isCollection = require('iterall').isCollection\r\n * isCollection([ 1, 2, 3 ]) // true\r\n * isCollection('ABC') // false\r\n * isCollection({ length: 1, 0: 'Alpha' }) // true\r\n * isCollection({ key: 'value' }) // false\r\n * isCollection(new Map()) // true\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n * if (isCollection(obj)) {\r\n *   forEach(obj, function (value) {\r\n *     console.log(value)\r\n *   })\r\n * }\r\n *\r\n * @param obj\r\n *   An Object value which might implement the Iterable or Array-like protocols.\r\n * @return {boolean} true if Iterable or Array-like Object.\r\n */\n\n/*:: declare export function isCollection(obj: any): boolean; */\n\nexport function isCollection(obj) {\n  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj));\n}\n/**\r\n * If the provided object implements the Iterator protocol, its Iterator object\r\n * is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getIterator = require('iterall').getIterator\r\n * var iterator = getIterator([ 1, 2, 3 ])\r\n * iterator.next() // { value: 1, done: false }\r\n * iterator.next() // { value: 2, done: false }\r\n * iterator.next() // { value: 3, done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which is the source of an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\n\n/*:: declare export var getIterator:\r\n  & (<+TValue>(iterable: Iterable<TValue>) => Iterator<TValue>)\r\n  & ((iterable: mixed) => void | Iterator<mixed>); */\n\nexport function getIterator(iterable) {\n  var method = getIteratorMethod(iterable);\n\n  if (method) {\n    return method.call(iterable);\n  }\n}\n/**\r\n * If the provided object implements the Iterator protocol, the method\r\n * responsible for producing its Iterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getIteratorMethod = require('iterall').getIteratorMethod\r\n * var myArray = [ 1, 2, 3 ]\r\n * var method = getIteratorMethod(myArray)\r\n * if (method) {\r\n *   var iterator = method.call(myArray)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which defines an `@@iterator` method.\r\n * @return {function(): Iterator<T>} `@@iterator` method.\r\n */\n\n/*:: declare export var getIteratorMethod:\r\n  & (<+TValue>(iterable: Iterable<TValue>) => (() => Iterator<TValue>))\r\n  & ((iterable: mixed) => (void | (() => Iterator<mixed>))); */\n\nexport function getIteratorMethod(iterable) {\n  if (iterable != null) {\n    var method = SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR] || iterable['@@iterator'];\n\n    if (typeof method === 'function') {\n      return method;\n    }\n  }\n}\n/**\r\n * Similar to {@link getIterator}, this method returns a new Iterator given an\r\n * Iterable. However it will also create an Iterator for a non-Iterable\r\n * Array-like collection, such as Array in a non-ES2015 environment.\r\n *\r\n * `createIterator` is complimentary to `forEach`, but allows a \"pull\"-based\r\n * iteration as opposed to `forEach`'s \"push\"-based iteration.\r\n *\r\n * `createIterator` produces an Iterator for Array-likes with the same behavior\r\n * as ArrayIteratorPrototype described in the ECMAScript specification, and\r\n * does *not* skip over \"holes\".\r\n *\r\n * @example\r\n *\r\n * var createIterator = require('iterall').createIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createIterator(myArraylike)\r\n * iterator.next() // { value: 'Alpha', done: false }\r\n * iterator.next() // { value: 'Bravo', done: false }\r\n * iterator.next() // { value: 'Charlie', done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   An Iterable or Array-like object to produce an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\n\n/*:: declare export var createIterator:\r\n  & (<+TValue>(collection: Iterable<TValue>) => Iterator<TValue>)\r\n  & ((collection: {length: number}) => Iterator<mixed>)\r\n  & ((collection: mixed) => (void | Iterator<mixed>)); */\n\nexport function createIterator(collection) {\n  if (collection != null) {\n    var iterator = getIterator(collection);\n\n    if (iterator) {\n      return iterator;\n    }\n\n    if (isArrayLike(collection)) {\n      return new ArrayLikeIterator(collection);\n    }\n  }\n} // When the object provided to `createIterator` is not Iterable but is\n// Array-like, this simple Iterator is created.\n\nfunction ArrayLikeIterator(obj) {\n  this._o = obj;\n  this._i = 0;\n} // Note: all Iterators are themselves Iterable.\n\n\nArrayLikeIterator.prototype[$$iterator] = function () {\n  return this;\n}; // A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\n\n\nArrayLikeIterator.prototype.next = function () {\n  if (this._o === void 0 || this._i >= this._o.length) {\n    this._o = void 0;\n    return {\n      value: void 0,\n      done: true\n    };\n  }\n\n  return {\n    value: this._o[this._i++],\n    done: false\n  };\n};\n/**\r\n * Given an object which either implements the Iterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forEach` where you would expect to use a `for ... of` loop in ES6.\r\n * However `forEach` adheres to the behavior of [Array#forEach][] described in\r\n * the ECMAScript specification, skipping over \"holes\" in Array-likes. It will\r\n * also delegate to a `forEach` method on `collection` if one is defined,\r\n * ensuring native performance for `Arrays`.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * Note: providing an infinite Iterator to forEach will produce an error.\r\n *\r\n * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n *\r\n * forEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES6:\r\n * for (let value of myIterable) {\r\n *   console.log(value)\r\n * }\r\n *\r\n * // Any JavaScript environment:\r\n * forEach(myIterable, function (value) {\r\n *   console.log(value)\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   The Iterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\n\n/*:: declare export var forEach:\r\n  & (<+TValue, TCollection: Iterable<TValue>>(\r\n      collection: TCollection,\r\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => void)\r\n  & (<TCollection: {length: number}>(\r\n      collection: TCollection,\r\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => void); */\n\n\nexport function forEach(collection, callback, thisArg) {\n  if (collection != null) {\n    if (typeof collection.forEach === 'function') {\n      return collection.forEach(callback, thisArg);\n    }\n\n    var i = 0;\n    var iterator = getIterator(collection);\n\n    if (iterator) {\n      var step;\n\n      while (!(step = iterator.next()).done) {\n        callback.call(thisArg, step.value, i++, collection); // Infinite Iterators could cause forEach to run forever.\n        // After a very large number of iterations, produce an error.\n\n        /* istanbul ignore if */\n\n        if (i > 9999999) {\n          throw new TypeError('Near-infinite iteration.');\n        }\n      }\n    } else if (isArrayLike(collection)) {\n      for (; i < collection.length; i++) {\n        if (collection.hasOwnProperty(i)) {\n          callback.call(thisArg, collection[i], i, collection);\n        }\n      }\n    }\n  }\n} /////////////////////////////////////////////////////\n//                                                 //\n//                 ASYNC ITERATORS                 //\n//                                                 //\n/////////////////////////////////////////////////////\n\n/**\r\n * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * an asynchronous iteration behavior, such as what values are looped over in\r\n * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)\r\n * loop or `iterall`'s {@link forAwaitEach} function.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterable\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}\r\n * @template T The type of each iterated value\r\n * @property {function (): AsyncIterator<T>} Symbol.asyncIterator\r\n *   A method which produces an AsyncIterator for this AsyncIterable.\r\n */\n\n/**\r\n * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)\r\n * is a *protocol* which describes a standard way to produce and consume an\r\n * asynchronous sequence of values, typically the values of the\r\n * {@link AsyncIterable} represented by this {@link AsyncIterator}.\r\n *\r\n * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it\r\n * also as a `next()` method, however instead of an IteratorResult,\r\n * calling this method returns a {@link Promise} for a IteratorResult.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterator\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}\r\n */\n// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\n\nvar SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator;\n/**\r\n * A property name to be used as the name of an AsyncIterable's method\r\n * responsible for producing an Iterator, referred to as `@@asyncIterator`.\r\n * Typically represents the value `Symbol.asyncIterator` but falls back to the\r\n * string `\"@@asyncIterator\"` when `Symbol.asyncIterator` is not defined.\r\n *\r\n * Use `$$asyncIterator` for defining new AsyncIterables instead of\r\n * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,\r\n * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$asyncIterator = require('iterall').$$asyncIterator\r\n *\r\n * function Chirper (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Chirper.prototype[$$asyncIterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       return new Promise(resolve => {\r\n *         if (this.num >= this.to) {\r\n *           resolve({ value: undefined, done: true })\r\n *         } else {\r\n *           setTimeout(() => {\r\n *             resolve({ value: this.num++, done: false })\r\n *           }, 1000)\r\n *         }\r\n *       })\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var chirper = new Chirper(3)\r\n * for await (var number of chirper) {\r\n *   console.log(number) // 0 ...wait... 1 ...wait... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\n\n/*:: declare export var $$asyncIterator: '@@asyncIterator'; */\n\nexport var $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator';\n/**\r\n * Returns true if the provided object implements the AsyncIterator protocol via\r\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isAsyncIterable = require('iterall').isAsyncIterable\r\n * isAsyncIterable(myStream) // true\r\n * isAsyncIterable('ABC') // false\r\n *\r\n * @param obj\r\n *   A value which might implement the AsyncIterable protocol.\r\n * @return {boolean} true if AsyncIterable.\r\n */\n\n/*:: declare export function isAsyncIterable(obj: any): boolean; */\n\nexport function isAsyncIterable(obj) {\n  return !!getAsyncIteratorMethod(obj);\n}\n/**\r\n * If the provided object implements the AsyncIterator protocol, its\r\n * AsyncIterator object is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIterator = require('iterall').getAsyncIterator\r\n * var asyncIterator = getAsyncIterator(myStream)\r\n * asyncIterator.next().then(console.log) // { value: 1, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 2, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 3, done: false }\r\n * asyncIterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which is the source of an AsyncIterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\n\n/*:: declare export var getAsyncIterator:\r\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => AsyncIterator<TValue>)\r\n  & ((asyncIterable: mixed) => (void | AsyncIterator<mixed>)); */\n\nexport function getAsyncIterator(asyncIterable) {\n  var method = getAsyncIteratorMethod(asyncIterable);\n\n  if (method) {\n    return method.call(asyncIterable);\n  }\n}\n/**\r\n * If the provided object implements the AsyncIterator protocol, the method\r\n * responsible for producing its AsyncIterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod\r\n * var method = getAsyncIteratorMethod(myStream)\r\n * if (method) {\r\n *   var asyncIterator = method.call(myStream)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which defines an `@@asyncIterator` method.\r\n * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.\r\n */\n\n/*:: declare export var getAsyncIteratorMethod:\r\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => (() => AsyncIterator<TValue>))\r\n  & ((asyncIterable: mixed) => (void | (() => AsyncIterator<mixed>))); */\n\nexport function getAsyncIteratorMethod(asyncIterable) {\n  if (asyncIterable != null) {\n    var method = SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR] || asyncIterable['@@asyncIterator'];\n\n    if (typeof method === 'function') {\n      return method;\n    }\n  }\n}\n/**\r\n * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator\r\n * given an AsyncIterable. However it will also create an AsyncIterator for a\r\n * non-async Iterable as well as non-Iterable Array-like collection, such as\r\n * Array in a pre-ES2015 environment.\r\n *\r\n * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a\r\n * buffering \"pull\"-based iteration as opposed to `forAwaitEach`'s\r\n * \"push\"-based iteration.\r\n *\r\n * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as\r\n * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).\r\n *\r\n * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var createAsyncIterator = require('iterall').createAsyncIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createAsyncIterator(myArraylike)\r\n * iterator.next().then(console.log) // { value: 'Alpha', done: false }\r\n * iterator.next().then(console.log) // { value: 'Bravo', done: false }\r\n * iterator.next().then(console.log) // { value: 'Charlie', done: false }\r\n * iterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source\r\n *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\n\n/*:: declare export var createAsyncIterator:\r\n  & (<+TValue>(\r\n      collection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>\r\n    ) => AsyncIterator<TValue>)\r\n  & ((collection: {length: number}) => AsyncIterator<mixed>)\r\n  & ((collection: mixed) => (void | AsyncIterator<mixed>)); */\n\nexport function createAsyncIterator(source) {\n  if (source != null) {\n    var asyncIterator = getAsyncIterator(source);\n\n    if (asyncIterator) {\n      return asyncIterator;\n    }\n\n    var iterator = createIterator(source);\n\n    if (iterator) {\n      return new AsyncFromSyncIterator(iterator);\n    }\n  }\n} // When the object provided to `createAsyncIterator` is not AsyncIterable but is\n// sync Iterable, this simple wrapper is created.\n\nfunction AsyncFromSyncIterator(iterator) {\n  this._i = iterator;\n} // Note: all AsyncIterators are themselves AsyncIterable.\n\n\nAsyncFromSyncIterator.prototype[$$asyncIterator] = function () {\n  return this;\n}; // A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\n\n\nAsyncFromSyncIterator.prototype.next = function (value) {\n  return unwrapAsyncFromSync(this._i, 'next', value);\n};\n\nAsyncFromSyncIterator.prototype.return = function (value) {\n  return this._i.return ? unwrapAsyncFromSync(this._i, 'return', value) : Promise.resolve({\n    value: value,\n    done: true\n  });\n};\n\nAsyncFromSyncIterator.prototype.throw = function (value) {\n  return this._i.throw ? unwrapAsyncFromSync(this._i, 'throw', value) : Promise.reject(value);\n};\n\nfunction unwrapAsyncFromSync(iterator, fn, value) {\n  var step;\n  return new Promise(function (resolve) {\n    step = iterator[fn](value);\n    resolve(step.value);\n  }).then(function (value) {\n    return {\n      value: value,\n      done: step.done\n    };\n  });\n}\n/**\r\n * Given an object which either implements the AsyncIterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * > Note: Using `forAwaitEach` requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var forAwaitEach = require('iterall').forAwaitEach\r\n *\r\n * forAwaitEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES2017:\r\n * for await (let value of myAsyncIterable) {\r\n *   console.log(await doSomethingAsync(value))\r\n * }\r\n * console.log('done')\r\n *\r\n * // Any JavaScript environment:\r\n * forAwaitEach(myAsyncIterable, function (value) {\r\n *   return doSomethingAsync(value).then(console.log)\r\n * }).then(function () {\r\n *   console.log('done')\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source\r\n *   The AsyncIterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\n\n/*:: declare export var forAwaitEach:\r\n  & (<+TValue, TCollection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>>(\r\n      collection: TCollection,\r\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => Promise<void>)\r\n  & (<TCollection: { length: number }>(\r\n      collection: TCollection,\r\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => Promise<void>); */\n\n\nexport function forAwaitEach(source, callback, thisArg) {\n  var asyncIterator = createAsyncIterator(source);\n\n  if (asyncIterator) {\n    var i = 0;\n    return new Promise(function (resolve, reject) {\n      function next() {\n        asyncIterator.next().then(function (step) {\n          if (!step.done) {\n            Promise.resolve(callback.call(thisArg, step.value, i++, source)).then(next).catch(reject);\n          } else {\n            resolve();\n          } // Explicitly return null, silencing bluebird-style warnings.\n\n\n          return null;\n        }).catch(reject); // Explicitly return null, silencing bluebird-style warnings.\n\n        return null;\n      }\n\n      next();\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/iterall/index.mjs"],"names":["SYMBOL","Symbol","SYMBOL_ITERATOR","iterator","$$iterator","isIterable","obj","getIteratorMethod","isArrayLike","length","isCollection","Object","getIterator","iterable","method","call","createIterator","collection","ArrayLikeIterator","_o","_i","prototype","next","value","done","forEach","callback","thisArg","i","step","TypeError","hasOwnProperty","SYMBOL_ASYNC_ITERATOR","asyncIterator","$$asyncIterator","isAsyncIterable","getAsyncIteratorMethod","getAsyncIterator","asyncIterable","createAsyncIterator","source","AsyncFromSyncIterator","unwrapAsyncFromSync","return","Promise","resolve","throw","reject","fn","then","forAwaitEach","catch"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,IAAIA;AAAO;AAAD,EAAc,OAAOC,MAAP,KAAkB,UAAlB,GAA+BA,MAA/B,GAAwC,KAAK,CAArE,C,CAEA;;AACA,IAAIC,eAAe,GAAGF,MAAM,IAAIA,MAAM,CAACG,QAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO,IAAIC,UAAU,GAAGF,eAAe,IAAI,YAApC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO,SAASG,UAAT,CAAoBC,GAApB,EAAyB;AAC9B,SAAO,CAAC,CAACC,iBAAiB,CAACD,GAAD,CAA1B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO,SAASE,WAAT,CAAqBF,GAArB,EAA0B;AAC/B,MAAIG,MAAM,GAAGH,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACG,MAAhC;AACA,SAAO,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,IAAI,CAAxC,IAA6CA,MAAM,GAAG,CAAT,KAAe,CAAnE;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO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,QAAQ,CAACmB,IAAT,EAAR,EAAyBE,IAAjC,EAAuC;AACrCE,QAAAA,QAAQ,CAACX,IAAT,CAAcY,OAAd,EAAuBE,IAAI,CAACN,KAA5B,EAAmCK,CAAC,EAApC,EAAwCX,UAAxC,EADqC,CAErC;AACA;;AACA;;AACA,YAAIW,CAAC,GAAG,OAAR,EAAiB;AACf,gBAAM,IAAIE,SAAJ,CAAc,0BAAd,CAAN;AACD;AACF;AACF,KAXD,MAWO,IAAItB,WAAW,CAACS,UAAD,CAAf,EAA6B;AAClC,aAAOW,CAAC,GAAGX,UAAU,CAACR,MAAtB,EAA8BmB,CAAC,EAA/B,EAAmC;AACjC,YAAIX,UAAU,CAACc,cAAX,CAA0BH,CAA1B,CAAJ,EAAkC;AAChCF,UAAAA,QAAQ,CAACX,IAAT,CAAcY,OAAd,EAAuBV,UAAU,CAACW,CAAD,CAAjC,EAAsCA,CAAtC,EAAyCX,UAAzC;AACD;AACF;AACF;AACF;AACF,C,CAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,IAAIe,qBAAqB,GAAGhC,MAAM,IAAIA,MAAM,CAACiC,aAA7C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO,IAAIC,eAAe,GAAGF,qBAAqB,IAAI,iBAA/C;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,OAAO,SAASG,eAAT,CAAyB7B,GAAzB,EAA8B;AACnC,SAAO,CAAC,CAAC8B,sBAAsB,CAAC9B,GAAD,CAA/B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,OAAO,SAAS+B,gBAAT,CAA0BC,aAA1B,EAAyC;AAC9C,MAAIxB,MAAM,GAAGsB,sBAAsB,CAACE,aAAD,CAAnC;;AACA,MAAIxB,MAAJ,EAAY;AACV,WAAOA,MAAM,CAACC,IAAP,CAAYuB,aAAZ,CAAP;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,OAAO,SAASF,sBAAT,CAAgCE,aAAhC,EAA+C;AACpD,MAAIA,aAAa,IAAI,IAArB,EAA2B;AACzB,QAAIxB,MAAM,GACPkB,qBAAqB,IAAIM,aAAa,CAACN,qBAAD,CAAvC,IACAM,aAAa,CAAC,iBAAD,CAFf;;AAGA,QAAI,OAAOxB,MAAP,KAAkB,UAAtB,EAAkC;AAChC,aAAOA,MAAP;AACD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASyB,mBAAT,CAA6BC,MAA7B,EAAqC;AAC1C,MAAIA,MAAM,IAAI,IAAd,EAAoB;AAClB,QAAIP,aAAa,GAAGI,gBAAgB,CAACG,MAAD,CAApC;;AACA,QAAIP,aAAJ,EAAmB;AACjB,aAAOA,aAAP;AACD;;AACD,QAAI9B,QAAQ,GAAGa,cAAc,CAACwB,MAAD,CAA7B;;AACA,QAAIrC,QAAJ,EAAc;AACZ,aAAO,IAAIsC,qBAAJ,CAA0BtC,QAA1B,CAAP;AACD;AACF;AACF,C,CAED;AACA;;AACA,SAASsC,qBAAT,CAA+BtC,QAA/B,EAAyC;AACvC,OAAKiB,EAAL,GAAUjB,QAAV;AACD,C,CAED;;;AACAsC,qBAAqB,CAACpB,SAAtB,CAAgCa,eAAhC,IAAmD,YAAW;AAC5D,SAAO,IAAP;AACD,CAFD,C,CAIA;AACA;;;AACAO,qBAAqB,CAACpB,SAAtB,CAAgCC,IAAhC,GAAuC,UAASC,KAAT,EAAgB;AACrD,SAAOmB,mBAAmB,CAAC,KAAKtB,EAAN,EAAU,MAAV,EAAkBG,KAAlB,CAA1B;AACD,CAFD;;AAIAkB,qBAAqB,CAACpB,SAAtB,CAAgCsB,MAAhC,GAAyC,UAASpB,KAAT,EAAgB;AACvD,SAAO,KAAKH,EAAL,CAAQuB,MAAR,GACHD,mBAAmB,CAAC,KAAKtB,EAAN,EAAU,QAAV,EAAoBG,KAApB,CADhB,GAEHqB,OAAO,CAACC,OAAR,CAAgB;AAAEtB,IAAAA,KAAK,EAAEA,KAAT;AAAgBC,IAAAA,IAAI,EAAE;AAAtB,GAAhB,CAFJ;AAGD,CAJD;;AAMAiB,qBAAqB,CAACpB,SAAtB,CAAgCyB,KAAhC,GAAwC,UAASvB,KAAT,EAAgB;AACtD,SAAO,KAAKH,EAAL,CAAQ0B,KAAR,GACHJ,mBAAmB,CAAC,KAAKtB,EAAN,EAAU,OAAV,EAAmBG,KAAnB,CADhB,GAEHqB,OAAO,CAACG,MAAR,CAAexB,KAAf,CAFJ;AAGD,CAJD;;AAMA,SAASmB,mBAAT,CAA6BvC,QAA7B,EAAuC6C,EAAvC,EAA2CzB,KAA3C,EAAkD;AAChD,MAAIM,IAAJ;AACA,SAAO,IAAIe,OAAJ,CAAY,UAASC,OAAT,EAAkB;AACnChB,IAAAA,IAAI,GAAG1B,QAAQ,CAAC6C,EAAD,CAAR,CAAazB,KAAb,CAAP;AACAsB,IAAAA,OAAO,CAAChB,IAAI,CAACN,KAAN,CAAP;AACD,GAHM,EAGJ0B,IAHI,CAGC,UAAS1B,KAAT,EAAgB;AACtB,WAAO;AAAEA,MAAAA,KAAK,EAAEA,KAAT;AAAgBC,MAAAA,IAAI,EAAEK,IAAI,CAACL;AAA3B,KAAP;AACD,GALM,CAAP;AAMD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAS0B,YAAT,CAAsBV,MAAtB,EAA8Bd,QAA9B,EAAwCC,OAAxC,EAAiD;AACtD,MAAIM,aAAa,GAAGM,mBAAmB,CAACC,MAAD,CAAvC;;AACA,MAAIP,aAAJ,EAAmB;AACjB,QAAIL,CAAC,GAAG,CAAR;AACA,WAAO,IAAIgB,OAAJ,CAAY,UAASC,OAAT,EAAkBE,MAAlB,EAA0B;AAC3C,eAASzB,IAAT,GAAgB;AACdW,QAAAA,aAAa,CACVX,IADH,GAEG2B,IAFH,CAEQ,UAASpB,IAAT,EAAe;AACnB,cAAI,CAACA,IAAI,CAACL,IAAV,EAAgB;AACdoB,YAAAA,OAAO,CAACC,OAAR,CAAgBnB,QAAQ,CAACX,IAAT,CAAcY,OAAd,EAAuBE,IAAI,CAACN,KAA5B,EAAmCK,CAAC,EAApC,EAAwCY,MAAxC,CAAhB,EACGS,IADH,CACQ3B,IADR,EAEG6B,KAFH,CAESJ,MAFT;AAGD,WAJD,MAIO;AACLF,YAAAA,OAAO;AACR,WAPkB,CAQnB;;;AACA,iBAAO,IAAP;AACD,SAZH,EAaGM,KAbH,CAaSJ,MAbT,EADc,CAed;;AACA,eAAO,IAAP;AACD;;AACDzB,MAAAA,IAAI;AACL,KApBM,CAAP;AAqBD;AACF","sourcesContent":["/**\r\n * Copyright (c) 2016, Lee Byron\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n * @ignore\r\n */\r\n\r\n/**\r\n * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\r\n * is a *protocol* which describes a standard way to produce a sequence of\r\n * values, typically the values of the Iterable represented by this Iterator.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterator\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}\r\n */\r\n\r\n/**\r\n * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * their iteration behavior, such as what values are looped over in a\r\n * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\r\n * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)\r\n * implement the Iterable protocol, including `Array` and `Map`.\r\n *\r\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external Iterable\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}\r\n */\r\n\r\n// In ES2015 environments, Symbol exists\r\nvar SYMBOL /*: any */ = typeof Symbol === 'function' ? Symbol : void 0\r\n\r\n// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\r\nvar SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator\r\n\r\n/**\r\n * A property name to be used as the name of an Iterable's method responsible\r\n * for producing an Iterator, referred to as `@@iterator`. Typically represents\r\n * the value `Symbol.iterator` but falls back to the string `\"@@iterator\"` when\r\n * `Symbol.iterator` is not defined.\r\n *\r\n * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,\r\n * but do not use it for accessing existing Iterables, instead use\r\n * {@link getIterator} or {@link isIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$iterator = require('iterall').$$iterator\r\n *\r\n * function Counter (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Counter.prototype[$$iterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       if (this.num >= this.to) {\r\n *         return { value: undefined, done: true }\r\n *       }\r\n *       return { value: this.num++, done: false }\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var counter = new Counter(3)\r\n * for (var number of counter) {\r\n *   console.log(number) // 0 ... 1 ... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\r\n/*:: declare export var $$iterator: '@@iterator'; */\r\nexport var $$iterator = SYMBOL_ITERATOR || '@@iterator'\r\n\r\n/**\r\n * Returns true if the provided object implements the Iterator protocol via\r\n * either implementing a `Symbol.iterator` or `\"@@iterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isIterable = require('iterall').isIterable\r\n * isIterable([ 1, 2, 3 ]) // true\r\n * isIterable('ABC') // true\r\n * isIterable({ length: 1, 0: 'Alpha' }) // false\r\n * isIterable({ key: 'value' }) // false\r\n * isIterable(new Map()) // true\r\n *\r\n * @param obj\r\n *   A value which might implement the Iterable protocol.\r\n * @return {boolean} true if Iterable.\r\n */\r\n/*:: declare export function isIterable(obj: any): boolean; */\r\nexport function isIterable(obj) {\r\n  return !!getIteratorMethod(obj)\r\n}\r\n\r\n/**\r\n * Returns true if the provided object implements the Array-like protocol via\r\n * defining a positive-integer `length` property.\r\n *\r\n * @example\r\n *\r\n * var isArrayLike = require('iterall').isArrayLike\r\n * isArrayLike([ 1, 2, 3 ]) // true\r\n * isArrayLike('ABC') // true\r\n * isArrayLike({ length: 1, 0: 'Alpha' }) // true\r\n * isArrayLike({ key: 'value' }) // false\r\n * isArrayLike(new Map()) // false\r\n *\r\n * @param obj\r\n *   A value which might implement the Array-like protocol.\r\n * @return {boolean} true if Array-like.\r\n */\r\n/*:: declare export function isArrayLike(obj: any): boolean; */\r\nexport function isArrayLike(obj) {\r\n  var length = obj != null && obj.length\r\n  return typeof length === 'number' && length >= 0 && length % 1 === 0\r\n}\r\n\r\n/**\r\n * Returns true if the provided object is an Object (i.e. not a string literal)\r\n * and is either Iterable or Array-like.\r\n *\r\n * This may be used in place of [Array.isArray()][isArray] to determine if an\r\n * object should be iterated-over. It always excludes string literals and\r\n * includes Arrays (regardless of if it is Iterable). It also includes other\r\n * Array-like objects such as NodeList, TypedArray, and Buffer.\r\n *\r\n * @example\r\n *\r\n * var isCollection = require('iterall').isCollection\r\n * isCollection([ 1, 2, 3 ]) // true\r\n * isCollection('ABC') // false\r\n * isCollection({ length: 1, 0: 'Alpha' }) // true\r\n * isCollection({ key: 'value' }) // false\r\n * isCollection(new Map()) // true\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n * if (isCollection(obj)) {\r\n *   forEach(obj, function (value) {\r\n *     console.log(value)\r\n *   })\r\n * }\r\n *\r\n * @param obj\r\n *   An Object value which might implement the Iterable or Array-like protocols.\r\n * @return {boolean} true if Iterable or Array-like Object.\r\n */\r\n/*:: declare export function isCollection(obj: any): boolean; */\r\nexport function isCollection(obj) {\r\n  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))\r\n}\r\n\r\n/**\r\n * If the provided object implements the Iterator protocol, its Iterator object\r\n * is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getIterator = require('iterall').getIterator\r\n * var iterator = getIterator([ 1, 2, 3 ])\r\n * iterator.next() // { value: 1, done: false }\r\n * iterator.next() // { value: 2, done: false }\r\n * iterator.next() // { value: 3, done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which is the source of an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\r\n/*:: declare export var getIterator:\r\n  & (<+TValue>(iterable: Iterable<TValue>) => Iterator<TValue>)\r\n  & ((iterable: mixed) => void | Iterator<mixed>); */\r\nexport function getIterator(iterable) {\r\n  var method = getIteratorMethod(iterable)\r\n  if (method) {\r\n    return method.call(iterable)\r\n  }\r\n}\r\n\r\n/**\r\n * If the provided object implements the Iterator protocol, the method\r\n * responsible for producing its Iterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getIteratorMethod = require('iterall').getIteratorMethod\r\n * var myArray = [ 1, 2, 3 ]\r\n * var method = getIteratorMethod(myArray)\r\n * if (method) {\r\n *   var iterator = method.call(myArray)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>} iterable\r\n *   An Iterable object which defines an `@@iterator` method.\r\n * @return {function(): Iterator<T>} `@@iterator` method.\r\n */\r\n/*:: declare export var getIteratorMethod:\r\n  & (<+TValue>(iterable: Iterable<TValue>) => (() => Iterator<TValue>))\r\n  & ((iterable: mixed) => (void | (() => Iterator<mixed>))); */\r\nexport function getIteratorMethod(iterable) {\r\n  if (iterable != null) {\r\n    var method =\r\n      (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) || iterable['@@iterator']\r\n    if (typeof method === 'function') {\r\n      return method\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Similar to {@link getIterator}, this method returns a new Iterator given an\r\n * Iterable. However it will also create an Iterator for a non-Iterable\r\n * Array-like collection, such as Array in a non-ES2015 environment.\r\n *\r\n * `createIterator` is complimentary to `forEach`, but allows a \"pull\"-based\r\n * iteration as opposed to `forEach`'s \"push\"-based iteration.\r\n *\r\n * `createIterator` produces an Iterator for Array-likes with the same behavior\r\n * as ArrayIteratorPrototype described in the ECMAScript specification, and\r\n * does *not* skip over \"holes\".\r\n *\r\n * @example\r\n *\r\n * var createIterator = require('iterall').createIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createIterator(myArraylike)\r\n * iterator.next() // { value: 'Alpha', done: false }\r\n * iterator.next() // { value: 'Bravo', done: false }\r\n * iterator.next() // { value: 'Charlie', done: false }\r\n * iterator.next() // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   An Iterable or Array-like object to produce an Iterator.\r\n * @return {Iterator<T>} new Iterator instance.\r\n */\r\n/*:: declare export var createIterator:\r\n  & (<+TValue>(collection: Iterable<TValue>) => Iterator<TValue>)\r\n  & ((collection: {length: number}) => Iterator<mixed>)\r\n  & ((collection: mixed) => (void | Iterator<mixed>)); */\r\nexport function createIterator(collection) {\r\n  if (collection != null) {\r\n    var iterator = getIterator(collection)\r\n    if (iterator) {\r\n      return iterator\r\n    }\r\n    if (isArrayLike(collection)) {\r\n      return new ArrayLikeIterator(collection)\r\n    }\r\n  }\r\n}\r\n\r\n// When the object provided to `createIterator` is not Iterable but is\r\n// Array-like, this simple Iterator is created.\r\nfunction ArrayLikeIterator(obj) {\r\n  this._o = obj\r\n  this._i = 0\r\n}\r\n\r\n// Note: all Iterators are themselves Iterable.\r\nArrayLikeIterator.prototype[$$iterator] = function() {\r\n  return this\r\n}\r\n\r\n// A simple state-machine determines the IteratorResult returned, yielding\r\n// each value in the Array-like object in order of their indicies.\r\nArrayLikeIterator.prototype.next = function() {\r\n  if (this._o === void 0 || this._i >= this._o.length) {\r\n    this._o = void 0\r\n    return { value: void 0, done: true }\r\n  }\r\n  return { value: this._o[this._i++], done: false }\r\n}\r\n\r\n/**\r\n * Given an object which either implements the Iterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forEach` where you would expect to use a `for ... of` loop in ES6.\r\n * However `forEach` adheres to the behavior of [Array#forEach][] described in\r\n * the ECMAScript specification, skipping over \"holes\" in Array-likes. It will\r\n * also delegate to a `forEach` method on `collection` if one is defined,\r\n * ensuring native performance for `Arrays`.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * Note: providing an infinite Iterator to forEach will produce an error.\r\n *\r\n * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n *\r\n * @example\r\n *\r\n * var forEach = require('iterall').forEach\r\n *\r\n * forEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES6:\r\n * for (let value of myIterable) {\r\n *   console.log(value)\r\n * }\r\n *\r\n * // Any JavaScript environment:\r\n * forEach(myIterable, function (value) {\r\n *   console.log(value)\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {Iterable<T>|{ length: number }} collection\r\n *   The Iterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\r\n/*:: declare export var forEach:\r\n  & (<+TValue, TCollection: Iterable<TValue>>(\r\n      collection: TCollection,\r\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => void)\r\n  & (<TCollection: {length: number}>(\r\n      collection: TCollection,\r\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => void); */\r\nexport function forEach(collection, callback, thisArg) {\r\n  if (collection != null) {\r\n    if (typeof collection.forEach === 'function') {\r\n      return collection.forEach(callback, thisArg)\r\n    }\r\n    var i = 0\r\n    var iterator = getIterator(collection)\r\n    if (iterator) {\r\n      var step\r\n      while (!(step = iterator.next()).done) {\r\n        callback.call(thisArg, step.value, i++, collection)\r\n        // Infinite Iterators could cause forEach to run forever.\r\n        // After a very large number of iterations, produce an error.\r\n        /* istanbul ignore if */\r\n        if (i > 9999999) {\r\n          throw new TypeError('Near-infinite iteration.')\r\n        }\r\n      }\r\n    } else if (isArrayLike(collection)) {\r\n      for (; i < collection.length; i++) {\r\n        if (collection.hasOwnProperty(i)) {\r\n          callback.call(thisArg, collection[i], i, collection)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/////////////////////////////////////////////////////\r\n//                                                 //\r\n//                 ASYNC ITERATORS                 //\r\n//                                                 //\r\n/////////////////////////////////////////////////////\r\n\r\n/**\r\n * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)\r\n * is a *protocol* which when implemented allows a JavaScript object to define\r\n * an asynchronous iteration behavior, such as what values are looped over in\r\n * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)\r\n * loop or `iterall`'s {@link forAwaitEach} function.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterable\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}\r\n * @template T The type of each iterated value\r\n * @property {function (): AsyncIterator<T>} Symbol.asyncIterator\r\n *   A method which produces an AsyncIterator for this AsyncIterable.\r\n */\r\n\r\n/**\r\n * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)\r\n * is a *protocol* which describes a standard way to produce and consume an\r\n * asynchronous sequence of values, typically the values of the\r\n * {@link AsyncIterable} represented by this {@link AsyncIterator}.\r\n *\r\n * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it\r\n * also as a `next()` method, however instead of an IteratorResult,\r\n * calling this method returns a {@link Promise} for a IteratorResult.\r\n *\r\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\r\n * it can be utilized by any version of JavaScript.\r\n *\r\n * @external AsyncIterator\r\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}\r\n */\r\n\r\n// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\r\nvar SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator\r\n\r\n/**\r\n * A property name to be used as the name of an AsyncIterable's method\r\n * responsible for producing an Iterator, referred to as `@@asyncIterator`.\r\n * Typically represents the value `Symbol.asyncIterator` but falls back to the\r\n * string `\"@@asyncIterator\"` when `Symbol.asyncIterator` is not defined.\r\n *\r\n * Use `$$asyncIterator` for defining new AsyncIterables instead of\r\n * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,\r\n * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.\r\n *\r\n * @example\r\n *\r\n * var $$asyncIterator = require('iterall').$$asyncIterator\r\n *\r\n * function Chirper (to) {\r\n *   this.to = to\r\n * }\r\n *\r\n * Chirper.prototype[$$asyncIterator] = function () {\r\n *   return {\r\n *     to: this.to,\r\n *     num: 0,\r\n *     next () {\r\n *       return new Promise(resolve => {\r\n *         if (this.num >= this.to) {\r\n *           resolve({ value: undefined, done: true })\r\n *         } else {\r\n *           setTimeout(() => {\r\n *             resolve({ value: this.num++, done: false })\r\n *           }, 1000)\r\n *         }\r\n *       })\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * var chirper = new Chirper(3)\r\n * for await (var number of chirper) {\r\n *   console.log(number) // 0 ...wait... 1 ...wait... 2\r\n * }\r\n *\r\n * @type {Symbol|string}\r\n */\r\n/*:: declare export var $$asyncIterator: '@@asyncIterator'; */\r\nexport var $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator'\r\n\r\n/**\r\n * Returns true if the provided object implements the AsyncIterator protocol via\r\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\r\n *\r\n * @example\r\n *\r\n * var isAsyncIterable = require('iterall').isAsyncIterable\r\n * isAsyncIterable(myStream) // true\r\n * isAsyncIterable('ABC') // false\r\n *\r\n * @param obj\r\n *   A value which might implement the AsyncIterable protocol.\r\n * @return {boolean} true if AsyncIterable.\r\n */\r\n/*:: declare export function isAsyncIterable(obj: any): boolean; */\r\nexport function isAsyncIterable(obj) {\r\n  return !!getAsyncIteratorMethod(obj)\r\n}\r\n\r\n/**\r\n * If the provided object implements the AsyncIterator protocol, its\r\n * AsyncIterator object is returned. Otherwise returns undefined.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIterator = require('iterall').getAsyncIterator\r\n * var asyncIterator = getAsyncIterator(myStream)\r\n * asyncIterator.next().then(console.log) // { value: 1, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 2, done: false }\r\n * asyncIterator.next().then(console.log) // { value: 3, done: false }\r\n * asyncIterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which is the source of an AsyncIterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\r\n/*:: declare export var getAsyncIterator:\r\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => AsyncIterator<TValue>)\r\n  & ((asyncIterable: mixed) => (void | AsyncIterator<mixed>)); */\r\nexport function getAsyncIterator(asyncIterable) {\r\n  var method = getAsyncIteratorMethod(asyncIterable)\r\n  if (method) {\r\n    return method.call(asyncIterable)\r\n  }\r\n}\r\n\r\n/**\r\n * If the provided object implements the AsyncIterator protocol, the method\r\n * responsible for producing its AsyncIterator object is returned.\r\n *\r\n * This is used in rare cases for performance tuning. This method must be called\r\n * with obj as the contextual this-argument.\r\n *\r\n * @example\r\n *\r\n * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod\r\n * var method = getAsyncIteratorMethod(myStream)\r\n * if (method) {\r\n *   var asyncIterator = method.call(myStream)\r\n * }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>} asyncIterable\r\n *   An AsyncIterable object which defines an `@@asyncIterator` method.\r\n * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.\r\n */\r\n/*:: declare export var getAsyncIteratorMethod:\r\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => (() => AsyncIterator<TValue>))\r\n  & ((asyncIterable: mixed) => (void | (() => AsyncIterator<mixed>))); */\r\nexport function getAsyncIteratorMethod(asyncIterable) {\r\n  if (asyncIterable != null) {\r\n    var method =\r\n      (SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||\r\n      asyncIterable['@@asyncIterator']\r\n    if (typeof method === 'function') {\r\n      return method\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator\r\n * given an AsyncIterable. However it will also create an AsyncIterator for a\r\n * non-async Iterable as well as non-Iterable Array-like collection, such as\r\n * Array in a pre-ES2015 environment.\r\n *\r\n * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a\r\n * buffering \"pull\"-based iteration as opposed to `forAwaitEach`'s\r\n * \"push\"-based iteration.\r\n *\r\n * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as\r\n * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).\r\n *\r\n * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var createAsyncIterator = require('iterall').createAsyncIterator\r\n *\r\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\r\n * var iterator = createAsyncIterator(myArraylike)\r\n * iterator.next().then(console.log) // { value: 'Alpha', done: false }\r\n * iterator.next().then(console.log) // { value: 'Bravo', done: false }\r\n * iterator.next().then(console.log) // { value: 'Charlie', done: false }\r\n * iterator.next().then(console.log) // { value: undefined, done: true }\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source\r\n *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.\r\n * @return {AsyncIterator<T>} new AsyncIterator instance.\r\n */\r\n/*:: declare export var createAsyncIterator:\r\n  & (<+TValue>(\r\n      collection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>\r\n    ) => AsyncIterator<TValue>)\r\n  & ((collection: {length: number}) => AsyncIterator<mixed>)\r\n  & ((collection: mixed) => (void | AsyncIterator<mixed>)); */\r\nexport function createAsyncIterator(source) {\r\n  if (source != null) {\r\n    var asyncIterator = getAsyncIterator(source)\r\n    if (asyncIterator) {\r\n      return asyncIterator\r\n    }\r\n    var iterator = createIterator(source)\r\n    if (iterator) {\r\n      return new AsyncFromSyncIterator(iterator)\r\n    }\r\n  }\r\n}\r\n\r\n// When the object provided to `createAsyncIterator` is not AsyncIterable but is\r\n// sync Iterable, this simple wrapper is created.\r\nfunction AsyncFromSyncIterator(iterator) {\r\n  this._i = iterator\r\n}\r\n\r\n// Note: all AsyncIterators are themselves AsyncIterable.\r\nAsyncFromSyncIterator.prototype[$$asyncIterator] = function() {\r\n  return this\r\n}\r\n\r\n// A simple state-machine determines the IteratorResult returned, yielding\r\n// each value in the Array-like object in order of their indicies.\r\nAsyncFromSyncIterator.prototype.next = function(value) {\r\n  return unwrapAsyncFromSync(this._i, 'next', value)\r\n}\r\n\r\nAsyncFromSyncIterator.prototype.return = function(value) {\r\n  return this._i.return\r\n    ? unwrapAsyncFromSync(this._i, 'return', value)\r\n    : Promise.resolve({ value: value, done: true })\r\n}\r\n\r\nAsyncFromSyncIterator.prototype.throw = function(value) {\r\n  return this._i.throw\r\n    ? unwrapAsyncFromSync(this._i, 'throw', value)\r\n    : Promise.reject(value)\r\n}\r\n\r\nfunction unwrapAsyncFromSync(iterator, fn, value) {\r\n  var step\r\n  return new Promise(function(resolve) {\r\n    step = iterator[fn](value)\r\n    resolve(step.value)\r\n  }).then(function(value) {\r\n    return { value: value, done: step.done }\r\n  })\r\n}\r\n\r\n/**\r\n * Given an object which either implements the AsyncIterable protocol or is\r\n * Array-like, iterate over it, calling the `callback` at each iteration.\r\n *\r\n * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.\r\n *\r\n * Similar to [Array#forEach][], the `callback` function accepts three\r\n * arguments, and is provided with `thisArg` as the calling context.\r\n *\r\n * > Note: Using `forAwaitEach` requires the existence of `Promise`.\r\n * > While `Promise` has been available in modern browsers for a number of\r\n * > years, legacy browsers (like IE 11) may require a polyfill.\r\n *\r\n * @example\r\n *\r\n * var forAwaitEach = require('iterall').forAwaitEach\r\n *\r\n * forAwaitEach(myIterable, function (value, index, iterable) {\r\n *   console.log(value, index, iterable === myIterable)\r\n * })\r\n *\r\n * @example\r\n *\r\n * // ES2017:\r\n * for await (let value of myAsyncIterable) {\r\n *   console.log(await doSomethingAsync(value))\r\n * }\r\n * console.log('done')\r\n *\r\n * // Any JavaScript environment:\r\n * forAwaitEach(myAsyncIterable, function (value) {\r\n *   return doSomethingAsync(value).then(console.log)\r\n * }).then(function () {\r\n *   console.log('done')\r\n * })\r\n *\r\n * @template T the type of each iterated value\r\n * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source\r\n *   The AsyncIterable or array to iterate over.\r\n * @param {function(T, number, object)} callback\r\n *   Function to execute for each iteration, taking up to three arguments\r\n * @param [thisArg]\r\n *   Optional. Value to use as `this` when executing `callback`.\r\n */\r\n/*:: declare export var forAwaitEach:\r\n  & (<+TValue, TCollection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>>(\r\n      collection: TCollection,\r\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => Promise<void>)\r\n  & (<TCollection: { length: number }>(\r\n      collection: TCollection,\r\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\r\n      thisArg?: any\r\n    ) => Promise<void>); */\r\nexport function forAwaitEach(source, callback, thisArg) {\r\n  var asyncIterator = createAsyncIterator(source)\r\n  if (asyncIterator) {\r\n    var i = 0\r\n    return new Promise(function(resolve, reject) {\r\n      function next() {\r\n        asyncIterator\r\n          .next()\r\n          .then(function(step) {\r\n            if (!step.done) {\r\n              Promise.resolve(callback.call(thisArg, step.value, i++, source))\r\n                .then(next)\r\n                .catch(reject)\r\n            } else {\r\n              resolve()\r\n            }\r\n            // Explicitly return null, silencing bluebird-style warnings.\r\n            return null\r\n          })\r\n          .catch(reject)\r\n        // Explicitly return null, silencing bluebird-style warnings.\r\n        return null\r\n      }\r\n      next()\r\n    })\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}