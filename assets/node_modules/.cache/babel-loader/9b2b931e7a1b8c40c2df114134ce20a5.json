{"ast":null,"code":"/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n/**\r\n * Build a GraphQLSchema for use by client tools.\r\n *\r\n * Given the result of a client running the introspection query, creates and\r\n * returns a GraphQLSchema instance which can be then used with all graphql-js\r\n * tools, but cannot be used to execute a query, as introspection does not\r\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\r\n * server-internal mechanisms.\r\n *\r\n * This function expects a complete introspection result. Don't forget to check\r\n * the \"errors\" field of a server response before calling this function.\r\n */\n\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["invariant","keyMap","keyValMap","valueFromAST","parseValue","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","buildClientSchema","introspection","options","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","concat","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","JSON","stringify","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","getOutputType","getObjectType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","serialize","value","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","buildDirective","directiveIntrospection","locations","slice","queryType","mutationType","subscriptionType","directives","query","mutation","subscription","assumeValid","allowedLegacyNames"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\r\nimport invariant from '../jsutils/invariant';\r\nimport keyMap from '../jsutils/keyMap';\r\nimport keyValMap from '../jsutils/keyValMap';\r\nimport { valueFromAST } from './valueFromAST';\r\nimport { parseValue } from '../language/parser';\r\nimport { GraphQLSchema } from '../type/schema';\r\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\r\nimport { GraphQLDirective } from '../type/directives';\r\nimport { introspectionTypes, TypeKind } from '../type/introspection';\r\nimport { specifiedScalarTypes } from '../type/scalars';\r\n\r\n/**\r\n * Build a GraphQLSchema for use by client tools.\r\n *\r\n * Given the result of a client running the introspection query, creates and\r\n * returns a GraphQLSchema instance which can be then used with all graphql-js\r\n * tools, but cannot be used to execute a query, as introspection does not\r\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\r\n * server-internal mechanisms.\r\n *\r\n * This function expects a complete introspection result. Don't forget to check\r\n * the \"errors\" field of a server response before calling this function.\r\n */\r\nexport function buildClientSchema(introspection, options) {\r\n  // Get the schema from the introspection result.\r\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\r\n\r\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\r\n    return type.name;\r\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\r\n  // Initialize to the GraphQL built in scalars. All functions below are inline\r\n  // so that this type def cache is within the scope of the closure.\r\n\r\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\r\n    return type.name;\r\n  }); // Given a type reference in introspection, return the GraphQLType instance.\r\n  // preferring cached instances before building new instances.\r\n\r\n  function getType(typeRef) {\r\n    if (typeRef.kind === TypeKind.LIST) {\r\n      var itemRef = typeRef.ofType;\r\n\r\n      if (!itemRef) {\r\n        throw new Error('Decorated type deeper than introspection query.');\r\n      }\r\n\r\n      return GraphQLList(getType(itemRef));\r\n    }\r\n\r\n    if (typeRef.kind === TypeKind.NON_NULL) {\r\n      var nullableRef = typeRef.ofType;\r\n\r\n      if (!nullableRef) {\r\n        throw new Error('Decorated type deeper than introspection query.');\r\n      }\r\n\r\n      var nullableType = getType(nullableRef);\r\n      return GraphQLNonNull(assertNullableType(nullableType));\r\n    }\r\n\r\n    if (!typeRef.name) {\r\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\r\n    }\r\n\r\n    return getNamedType(typeRef.name);\r\n  }\r\n\r\n  function getNamedType(typeName) {\r\n    if (typeDefCache[typeName]) {\r\n      return typeDefCache[typeName];\r\n    }\r\n\r\n    var typeIntrospection = typeIntrospectionMap[typeName];\r\n\r\n    if (!typeIntrospection) {\r\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\r\n    }\r\n\r\n    var typeDef = buildType(typeIntrospection);\r\n    typeDefCache[typeName] = typeDef;\r\n    return typeDef;\r\n  }\r\n\r\n  function getInputType(typeRef) {\r\n    var type = getType(typeRef);\r\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\r\n    return type;\r\n  }\r\n\r\n  function getOutputType(typeRef) {\r\n    var type = getType(typeRef);\r\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\r\n    return type;\r\n  }\r\n\r\n  function getObjectType(typeRef) {\r\n    var type = getType(typeRef);\r\n    return assertObjectType(type);\r\n  }\r\n\r\n  function getInterfaceType(typeRef) {\r\n    var type = getType(typeRef);\r\n    return assertInterfaceType(type);\r\n  } // Given a type's introspection result, construct the correct\r\n  // GraphQLType instance.\r\n\r\n\r\n  function buildType(type) {\r\n    if (type && type.name && type.kind) {\r\n      switch (type.kind) {\r\n        case TypeKind.SCALAR:\r\n          return buildScalarDef(type);\r\n\r\n        case TypeKind.OBJECT:\r\n          return buildObjectDef(type);\r\n\r\n        case TypeKind.INTERFACE:\r\n          return buildInterfaceDef(type);\r\n\r\n        case TypeKind.UNION:\r\n          return buildUnionDef(type);\r\n\r\n        case TypeKind.ENUM:\r\n          return buildEnumDef(type);\r\n\r\n        case TypeKind.INPUT_OBJECT:\r\n          return buildInputObjectDef(type);\r\n      }\r\n    }\r\n\r\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\r\n  }\r\n\r\n  function buildScalarDef(scalarIntrospection) {\r\n    return new GraphQLScalarType({\r\n      name: scalarIntrospection.name,\r\n      description: scalarIntrospection.description,\r\n      serialize: function serialize(value) {\r\n        return value;\r\n      }\r\n    });\r\n  }\r\n\r\n  function buildObjectDef(objectIntrospection) {\r\n    if (!objectIntrospection.interfaces) {\r\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\r\n    }\r\n\r\n    return new GraphQLObjectType({\r\n      name: objectIntrospection.name,\r\n      description: objectIntrospection.description,\r\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\r\n      fields: function fields() {\r\n        return buildFieldDefMap(objectIntrospection);\r\n      }\r\n    });\r\n  }\r\n\r\n  function buildInterfaceDef(interfaceIntrospection) {\r\n    return new GraphQLInterfaceType({\r\n      name: interfaceIntrospection.name,\r\n      description: interfaceIntrospection.description,\r\n      fields: function fields() {\r\n        return buildFieldDefMap(interfaceIntrospection);\r\n      }\r\n    });\r\n  }\r\n\r\n  function buildUnionDef(unionIntrospection) {\r\n    if (!unionIntrospection.possibleTypes) {\r\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\r\n    }\r\n\r\n    return new GraphQLUnionType({\r\n      name: unionIntrospection.name,\r\n      description: unionIntrospection.description,\r\n      types: unionIntrospection.possibleTypes.map(getObjectType)\r\n    });\r\n  }\r\n\r\n  function buildEnumDef(enumIntrospection) {\r\n    if (!enumIntrospection.enumValues) {\r\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\r\n    }\r\n\r\n    return new GraphQLEnumType({\r\n      name: enumIntrospection.name,\r\n      description: enumIntrospection.description,\r\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\r\n        return valueIntrospection.name;\r\n      }, function (valueIntrospection) {\r\n        return {\r\n          description: valueIntrospection.description,\r\n          deprecationReason: valueIntrospection.deprecationReason\r\n        };\r\n      })\r\n    });\r\n  }\r\n\r\n  function buildInputObjectDef(inputObjectIntrospection) {\r\n    if (!inputObjectIntrospection.inputFields) {\r\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\r\n    }\r\n\r\n    return new GraphQLInputObjectType({\r\n      name: inputObjectIntrospection.name,\r\n      description: inputObjectIntrospection.description,\r\n      fields: function fields() {\r\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\r\n      }\r\n    });\r\n  }\r\n\r\n  function buildFieldDefMap(typeIntrospection) {\r\n    if (!typeIntrospection.fields) {\r\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\r\n    }\r\n\r\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\r\n      return fieldIntrospection.name;\r\n    }, function (fieldIntrospection) {\r\n      if (!fieldIntrospection.args) {\r\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\r\n      }\r\n\r\n      return {\r\n        description: fieldIntrospection.description,\r\n        deprecationReason: fieldIntrospection.deprecationReason,\r\n        type: getOutputType(fieldIntrospection.type),\r\n        args: buildInputValueDefMap(fieldIntrospection.args)\r\n      };\r\n    });\r\n  }\r\n\r\n  function buildInputValueDefMap(inputValueIntrospections) {\r\n    return keyValMap(inputValueIntrospections, function (inputValue) {\r\n      return inputValue.name;\r\n    }, buildInputValue);\r\n  }\r\n\r\n  function buildInputValue(inputValueIntrospection) {\r\n    var type = getInputType(inputValueIntrospection.type);\r\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\r\n    return {\r\n      description: inputValueIntrospection.description,\r\n      type: type,\r\n      defaultValue: defaultValue\r\n    };\r\n  }\r\n\r\n  function buildDirective(directiveIntrospection) {\r\n    if (!directiveIntrospection.args) {\r\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\r\n    }\r\n\r\n    return new GraphQLDirective({\r\n      name: directiveIntrospection.name,\r\n      description: directiveIntrospection.description,\r\n      locations: directiveIntrospection.locations.slice(),\r\n      args: buildInputValueDefMap(directiveIntrospection.args)\r\n    });\r\n  } // Iterate through all types, getting the type definition for each, ensuring\r\n  // that any type not directly referenced by a field will get created.\r\n\r\n\r\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\r\n    return getNamedType(typeIntrospection.name);\r\n  }); // Get the root Query, Mutation, and Subscription types.\r\n\r\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\r\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\r\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\r\n  // directives were not queried for.\r\n\r\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\r\n\r\n  return new GraphQLSchema({\r\n    query: queryType,\r\n    mutation: mutationType,\r\n    subscription: subscriptionType,\r\n    types: types,\r\n    directives: directives,\r\n    assumeValid: options && options.assumeValid,\r\n    allowedLegacyNames: options && options.allowedLegacyNames\r\n  });\r\n}"]},"metadata":{},"sourceType":"module"}