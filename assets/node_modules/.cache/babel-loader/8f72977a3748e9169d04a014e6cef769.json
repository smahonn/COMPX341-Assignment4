{"ast":null,"code":"var AWS = require('../core');\n/**\r\n * @api private\r\n */\n\n\nvar service = null;\n/**\r\n * @api private\r\n */\n\nvar api = {\n  signatureVersion: 'v4',\n  signingName: 'rds-db'\n};\n/**\r\n * @api private\r\n */\n\nvar requiredAuthTokenOptions = {\n  region: 'string',\n  hostname: 'string',\n  port: 'number',\n  username: 'string'\n};\n/**\r\n * A signer object can be used to generate an auth token to a database.\r\n */\n\nAWS.RDS.Signer = AWS.util.inherit({\n  /**\r\n   * Creates a signer object can be used to generate an auth token.\r\n   *\r\n   * @option options credentials [AWS.Credentials] the AWS credentials\r\n   *   to sign requests with. Uses the default credential provider chain\r\n   *   if not specified.\r\n   * @option options hostname [String] the hostname of the database to connect to.\r\n   * @option options port [Number] the port number the database is listening on.\r\n   * @option options region [String] the region the database is located in.\r\n   * @option options username [String] the username to login as.\r\n   * @example Passing in options to constructor\r\n   *   var signer = new AWS.RDS.Signer({\r\n   *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\r\n   *     region: 'us-east-1',\r\n   *     hostname: 'db.us-east-1.rds.amazonaws.com',\r\n   *     port: 8000,\r\n   *     username: 'name'\r\n   *   });\r\n   */\n  constructor: function Signer(options) {\n    this.options = options || {};\n  },\n\n  /**\r\n   * @api private\r\n   * Strips the protocol from a url.\r\n   */\n  convertUrlToAuthToken: function convertUrlToAuthToken(url) {\n    // we are always using https as the protocol\n    var protocol = 'https://';\n\n    if (url.indexOf(protocol) === 0) {\n      return url.substring(protocol.length);\n    }\n  },\n\n  /**\r\n   * @overload getAuthToken(options = {}, [callback])\r\n   *   Generate an auth token to a database.\r\n   *   @note You must ensure that you have static or previously resolved\r\n   *     credentials if you call this method synchronously (with no callback),\r\n   *     otherwise it may not properly sign the request. If you cannot guarantee\r\n   *     this (you are using an asynchronous credential provider, i.e., EC2\r\n   *     IAM roles), you should always call this method with an asynchronous\r\n   *     callback.\r\n   *\r\n   *   @param options [map] The fields to use when generating an auth token.\r\n   *     Any options specified here will be merged on top of any options passed\r\n   *     to AWS.RDS.Signer:\r\n   *\r\n   *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\r\n   *         to sign requests with. Uses the default credential provider chain\r\n   *         if not specified.\r\n   *     * **hostname** (String) &mdash; the hostname of the database to connect to.\r\n   *     * **port** (Number) &mdash; the port number the database is listening on.\r\n   *     * **region** (String) &mdash; the region the database is located in.\r\n   *     * **username** (String) &mdash; the username to login as.\r\n   *   @return [String] if called synchronously (with no callback), returns the\r\n   *     auth token.\r\n   *   @return [null] nothing is returned if a callback is provided.\r\n   *   @callback callback function (err, token)\r\n   *     If a callback is supplied, it is called when an auth token has been generated.\r\n   *     @param err [Error] the error object returned from the signer.\r\n   *     @param token [String] the auth token.\r\n   *\r\n   *   @example Generating an auth token synchronously\r\n   *     var signer = new AWS.RDS.Signer({\r\n   *       // configure options\r\n   *       region: 'us-east-1',\r\n   *       username: 'default',\r\n   *       hostname: 'db.us-east-1.amazonaws.com',\r\n   *       port: 8000\r\n   *     });\r\n   *     var token = signer.getAuthToken({\r\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n   *       username: 'test' // overriding username\r\n   *     });\r\n   *   @example Generating an auth token asynchronously\r\n   *     var signer = new AWS.RDS.Signer({\r\n   *       // configure options\r\n   *       region: 'us-east-1',\r\n   *       username: 'default',\r\n   *       hostname: 'db.us-east-1.amazonaws.com',\r\n   *       port: 8000\r\n   *     });\r\n   *     signer.getAuthToken({\r\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n   *       username: 'test' // overriding username\r\n   *     }, function(err, token) {\r\n   *       if (err) {\r\n   *         // handle error\r\n   *       } else {\r\n   *         // use token\r\n   *       }\r\n   *     });\r\n   *\r\n   */\n  getAuthToken: function getAuthToken(options, callback) {\n    if (typeof options === 'function' && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    var self = this;\n    var hasCallback = typeof callback === 'function'; // merge options with existing options\n\n    options = AWS.util.merge(this.options, options); // validate options\n\n    var optionsValidation = this.validateAuthTokenOptions(options);\n\n    if (optionsValidation !== true) {\n      if (hasCallback) {\n        return callback(optionsValidation, null);\n      }\n\n      throw optionsValidation;\n    } // 15 minutes\n\n\n    var expires = 900; // create service to generate a request from\n\n    var serviceOptions = {\n      region: options.region,\n      endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\n      paramValidation: false,\n      signatureVersion: 'v4'\n    };\n\n    if (options.credentials) {\n      serviceOptions.credentials = options.credentials;\n    }\n\n    service = new AWS.Service(serviceOptions); // ensure the SDK is using sigv4 signing (config is not enough)\n\n    service.api = api;\n    var request = service.makeRequest(); // add listeners to request to properly build auth token\n\n    this.modifyRequestForAuthToken(request, options);\n\n    if (hasCallback) {\n      request.presign(expires, function (err, url) {\n        if (url) {\n          url = self.convertUrlToAuthToken(url);\n        }\n\n        callback(err, url);\n      });\n    } else {\n      var url = request.presign(expires);\n      return this.convertUrlToAuthToken(url);\n    }\n  },\n\n  /**\r\n   * @api private\r\n   * Modifies a request to allow the presigner to generate an auth token.\r\n   */\n  modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\n    request.on('build', request.buildAsGet);\n    var httpRequest = request.httpRequest;\n    httpRequest.body = AWS.util.queryParamsToString({\n      Action: 'connect',\n      DBUser: options.username\n    });\n  },\n\n  /**\r\n   * @api private\r\n   * Validates that the options passed in contain all the keys with values of the correct type that\r\n   *   are needed to generate an auth token.\r\n   */\n  validateAuthTokenOptions: function validateAuthTokenOptions(options) {\n    // iterate over all keys in options\n    var message = '';\n    options = options || {};\n\n    for (var key in requiredAuthTokenOptions) {\n      if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\n        continue;\n      }\n\n      if (typeof options[key] !== requiredAuthTokenOptions[key]) {\n        message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\n      }\n    }\n\n    if (message.length) {\n      return AWS.util.error(new Error(), {\n        code: 'InvalidParameter',\n        message: message\n      });\n    }\n\n    return true;\n  }\n});","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/rds/signer.js"],"names":["AWS","require","service","api","signatureVersion","signingName","requiredAuthTokenOptions","region","hostname","port","username","RDS","Signer","util","inherit","constructor","options","convertUrlToAuthToken","url","protocol","indexOf","substring","length","getAuthToken","callback","undefined","self","hasCallback","merge","optionsValidation","validateAuthTokenOptions","expires","serviceOptions","endpoint","Endpoint","paramValidation","credentials","Service","request","makeRequest","modifyRequestForAuthToken","presign","err","on","buildAsGet","httpRequest","body","queryParamsToString","Action","DBUser","message","key","Object","prototype","hasOwnProperty","call","error","Error","code"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAjB;AAEA;AACA;AACA;;;AACA,IAAIC,OAAO,GAAG,IAAd;AAEA;AACA;AACA;;AACA,IAAIC,GAAG,GAAG;AACNC,EAAAA,gBAAgB,EAAE,IADZ;AAENC,EAAAA,WAAW,EAAE;AAFP,CAAV;AAKA;AACA;AACA;;AACA,IAAIC,wBAAwB,GAAG;AAC3BC,EAAAA,MAAM,EAAE,QADmB;AAE3BC,EAAAA,QAAQ,EAAE,QAFiB;AAG3BC,EAAAA,IAAI,EAAE,QAHqB;AAI3BC,EAAAA,QAAQ,EAAE;AAJiB,CAA/B;AAOA;AACA;AACA;;AACAV,GAAG,CAACW,GAAJ,CAAQC,MAAR,GAAiBZ,GAAG,CAACa,IAAJ,CAASC,OAAT,CAAiB;AAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,EAAE,SAASH,MAAT,CAAgBI,OAAhB,EAAyB;AAClC,SAAKA,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACH,GAtB6B;;AAwB9B;AACJ;AACA;AACA;AACIC,EAAAA,qBAAqB,EAAE,SAASA,qBAAT,CAA+BC,GAA/B,EAAoC;AACvD;AACA,QAAIC,QAAQ,GAAG,UAAf;;AACA,QAAID,GAAG,CAACE,OAAJ,CAAYD,QAAZ,MAA0B,CAA9B,EAAiC;AAC7B,aAAOD,GAAG,CAACG,SAAJ,CAAcF,QAAQ,CAACG,MAAvB,CAAP;AACH;AACJ,GAlC6B;;AAoC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBP,OAAtB,EAA+BQ,QAA/B,EAAyC;AACnD,QAAI,OAAOR,OAAP,KAAmB,UAAnB,IAAiCQ,QAAQ,KAAKC,SAAlD,EAA6D;AACzDD,MAAAA,QAAQ,GAAGR,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACH;;AACD,QAAIU,IAAI,GAAG,IAAX;AACA,QAAIC,WAAW,GAAG,OAAOH,QAAP,KAAoB,UAAtC,CANmD,CAOnD;;AACAR,IAAAA,OAAO,GAAGhB,GAAG,CAACa,IAAJ,CAASe,KAAT,CAAe,KAAKZ,OAApB,EAA6BA,OAA7B,CAAV,CARmD,CASnD;;AACA,QAAIa,iBAAiB,GAAG,KAAKC,wBAAL,CAA8Bd,OAA9B,CAAxB;;AACA,QAAIa,iBAAiB,KAAK,IAA1B,EAAgC;AAC5B,UAAIF,WAAJ,EAAiB;AACb,eAAOH,QAAQ,CAACK,iBAAD,EAAoB,IAApB,CAAf;AACH;;AACD,YAAMA,iBAAN;AACH,KAhBkD,CAkBnD;;;AACA,QAAIE,OAAO,GAAG,GAAd,CAnBmD,CAoBnD;;AACA,QAAIC,cAAc,GAAG;AACjBzB,MAAAA,MAAM,EAAES,OAAO,CAACT,MADC;AAEjB0B,MAAAA,QAAQ,EAAE,IAAIjC,GAAG,CAACkC,QAAR,CAAiBlB,OAAO,CAACR,QAAR,GAAmB,GAAnB,GAAyBQ,OAAO,CAACP,IAAlD,CAFO;AAGjB0B,MAAAA,eAAe,EAAE,KAHA;AAIjB/B,MAAAA,gBAAgB,EAAE;AAJD,KAArB;;AAMA,QAAIY,OAAO,CAACoB,WAAZ,EAAyB;AACrBJ,MAAAA,cAAc,CAACI,WAAf,GAA6BpB,OAAO,CAACoB,WAArC;AACH;;AACDlC,IAAAA,OAAO,GAAG,IAAIF,GAAG,CAACqC,OAAR,CAAgBL,cAAhB,CAAV,CA9BmD,CA+BnD;;AACA9B,IAAAA,OAAO,CAACC,GAAR,GAAcA,GAAd;AAEA,QAAImC,OAAO,GAAGpC,OAAO,CAACqC,WAAR,EAAd,CAlCmD,CAmCnD;;AACA,SAAKC,yBAAL,CAA+BF,OAA/B,EAAwCtB,OAAxC;;AAEA,QAAIW,WAAJ,EAAiB;AACbW,MAAAA,OAAO,CAACG,OAAR,CAAgBV,OAAhB,EAAyB,UAASW,GAAT,EAAcxB,GAAd,EAAmB;AACxC,YAAIA,GAAJ,EAAS;AACLA,UAAAA,GAAG,GAAGQ,IAAI,CAACT,qBAAL,CAA2BC,GAA3B,CAAN;AACH;;AACDM,QAAAA,QAAQ,CAACkB,GAAD,EAAMxB,GAAN,CAAR;AACH,OALD;AAMH,KAPD,MAOO;AACH,UAAIA,GAAG,GAAGoB,OAAO,CAACG,OAAR,CAAgBV,OAAhB,CAAV;AACA,aAAO,KAAKd,qBAAL,CAA2BC,GAA3B,CAAP;AACH;AACJ,GApJ6B;;AAsJ9B;AACJ;AACA;AACA;AACIsB,EAAAA,yBAAyB,EAAE,SAASA,yBAAT,CAAmCF,OAAnC,EAA4CtB,OAA5C,EAAqD;AAC5EsB,IAAAA,OAAO,CAACK,EAAR,CAAW,OAAX,EAAoBL,OAAO,CAACM,UAA5B;AACA,QAAIC,WAAW,GAAGP,OAAO,CAACO,WAA1B;AACAA,IAAAA,WAAW,CAACC,IAAZ,GAAmB9C,GAAG,CAACa,IAAJ,CAASkC,mBAAT,CAA6B;AAC5CC,MAAAA,MAAM,EAAE,SADoC;AAE5CC,MAAAA,MAAM,EAAEjC,OAAO,CAACN;AAF4B,KAA7B,CAAnB;AAIH,GAjK6B;;AAmK9B;AACJ;AACA;AACA;AACA;AACIoB,EAAAA,wBAAwB,EAAE,SAASA,wBAAT,CAAkCd,OAAlC,EAA2C;AACjE;AACA,QAAIkC,OAAO,GAAG,EAAd;AACAlC,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,SAAK,IAAImC,GAAT,IAAgB7C,wBAAhB,EAA0C;AACtC,UAAI,CAAC8C,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCjD,wBAArC,EAA+D6C,GAA/D,CAAL,EAA0E;AACtE;AACH;;AACD,UAAI,OAAOnC,OAAO,CAACmC,GAAD,CAAd,KAAwB7C,wBAAwB,CAAC6C,GAAD,CAApD,EAA2D;AACvDD,QAAAA,OAAO,IAAI,cAAcC,GAAd,GAAoB,6BAApB,GAAoD7C,wBAAwB,CAAC6C,GAAD,CAA5E,GAAoF,YAApF,GAAmG,OAAOnC,OAAO,CAACmC,GAAD,CAAjH,GAAyH,OAApI;AACH;AACJ;;AACD,QAAID,OAAO,CAAC5B,MAAZ,EAAoB;AAChB,aAAOtB,GAAG,CAACa,IAAJ,CAAS2C,KAAT,CAAe,IAAIC,KAAJ,EAAf,EAA4B;AAC/BC,QAAAA,IAAI,EAAE,kBADyB;AAE/BR,QAAAA,OAAO,EAAEA;AAFsB,OAA5B,CAAP;AAIH;;AACD,WAAO,IAAP;AACH;AA3L6B,CAAjB,CAAjB","sourcesContent":["var AWS = require('../core');\r\n\r\n/**\r\n * @api private\r\n */\r\nvar service = null;\r\n\r\n/**\r\n * @api private\r\n */\r\nvar api = {\r\n    signatureVersion: 'v4',\r\n    signingName: 'rds-db'\r\n};\r\n\r\n/**\r\n * @api private\r\n */\r\nvar requiredAuthTokenOptions = {\r\n    region: 'string',\r\n    hostname: 'string',\r\n    port: 'number',\r\n    username: 'string'\r\n};\r\n\r\n/**\r\n * A signer object can be used to generate an auth token to a database.\r\n */\r\nAWS.RDS.Signer = AWS.util.inherit({\r\n    /**\r\n     * Creates a signer object can be used to generate an auth token.\r\n     *\r\n     * @option options credentials [AWS.Credentials] the AWS credentials\r\n     *   to sign requests with. Uses the default credential provider chain\r\n     *   if not specified.\r\n     * @option options hostname [String] the hostname of the database to connect to.\r\n     * @option options port [Number] the port number the database is listening on.\r\n     * @option options region [String] the region the database is located in.\r\n     * @option options username [String] the username to login as.\r\n     * @example Passing in options to constructor\r\n     *   var signer = new AWS.RDS.Signer({\r\n     *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\r\n     *     region: 'us-east-1',\r\n     *     hostname: 'db.us-east-1.rds.amazonaws.com',\r\n     *     port: 8000,\r\n     *     username: 'name'\r\n     *   });\r\n     */\r\n    constructor: function Signer(options) {\r\n        this.options = options || {};\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Strips the protocol from a url.\r\n     */\r\n    convertUrlToAuthToken: function convertUrlToAuthToken(url) {\r\n        // we are always using https as the protocol\r\n        var protocol = 'https://';\r\n        if (url.indexOf(protocol) === 0) {\r\n            return url.substring(protocol.length);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @overload getAuthToken(options = {}, [callback])\r\n     *   Generate an auth token to a database.\r\n     *   @note You must ensure that you have static or previously resolved\r\n     *     credentials if you call this method synchronously (with no callback),\r\n     *     otherwise it may not properly sign the request. If you cannot guarantee\r\n     *     this (you are using an asynchronous credential provider, i.e., EC2\r\n     *     IAM roles), you should always call this method with an asynchronous\r\n     *     callback.\r\n     *\r\n     *   @param options [map] The fields to use when generating an auth token.\r\n     *     Any options specified here will be merged on top of any options passed\r\n     *     to AWS.RDS.Signer:\r\n     *\r\n     *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\r\n     *         to sign requests with. Uses the default credential provider chain\r\n     *         if not specified.\r\n     *     * **hostname** (String) &mdash; the hostname of the database to connect to.\r\n     *     * **port** (Number) &mdash; the port number the database is listening on.\r\n     *     * **region** (String) &mdash; the region the database is located in.\r\n     *     * **username** (String) &mdash; the username to login as.\r\n     *   @return [String] if called synchronously (with no callback), returns the\r\n     *     auth token.\r\n     *   @return [null] nothing is returned if a callback is provided.\r\n     *   @callback callback function (err, token)\r\n     *     If a callback is supplied, it is called when an auth token has been generated.\r\n     *     @param err [Error] the error object returned from the signer.\r\n     *     @param token [String] the auth token.\r\n     *\r\n     *   @example Generating an auth token synchronously\r\n     *     var signer = new AWS.RDS.Signer({\r\n     *       // configure options\r\n     *       region: 'us-east-1',\r\n     *       username: 'default',\r\n     *       hostname: 'db.us-east-1.amazonaws.com',\r\n     *       port: 8000\r\n     *     });\r\n     *     var token = signer.getAuthToken({\r\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n     *       username: 'test' // overriding username\r\n     *     });\r\n     *   @example Generating an auth token asynchronously\r\n     *     var signer = new AWS.RDS.Signer({\r\n     *       // configure options\r\n     *       region: 'us-east-1',\r\n     *       username: 'default',\r\n     *       hostname: 'db.us-east-1.amazonaws.com',\r\n     *       port: 8000\r\n     *     });\r\n     *     signer.getAuthToken({\r\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n     *       username: 'test' // overriding username\r\n     *     }, function(err, token) {\r\n     *       if (err) {\r\n     *         // handle error\r\n     *       } else {\r\n     *         // use token\r\n     *       }\r\n     *     });\r\n     *\r\n     */\r\n    getAuthToken: function getAuthToken(options, callback) {\r\n        if (typeof options === 'function' && callback === undefined) {\r\n            callback = options;\r\n            options = {};\r\n        }\r\n        var self = this;\r\n        var hasCallback = typeof callback === 'function';\r\n        // merge options with existing options\r\n        options = AWS.util.merge(this.options, options);\r\n        // validate options\r\n        var optionsValidation = this.validateAuthTokenOptions(options);\r\n        if (optionsValidation !== true) {\r\n            if (hasCallback) {\r\n                return callback(optionsValidation, null);\r\n            }\r\n            throw optionsValidation;\r\n        }\r\n\r\n        // 15 minutes\r\n        var expires = 900;\r\n        // create service to generate a request from\r\n        var serviceOptions = {\r\n            region: options.region,\r\n            endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\r\n            paramValidation: false,\r\n            signatureVersion: 'v4'\r\n        };\r\n        if (options.credentials) {\r\n            serviceOptions.credentials = options.credentials;\r\n        }\r\n        service = new AWS.Service(serviceOptions);\r\n        // ensure the SDK is using sigv4 signing (config is not enough)\r\n        service.api = api;\r\n\r\n        var request = service.makeRequest();\r\n        // add listeners to request to properly build auth token\r\n        this.modifyRequestForAuthToken(request, options);\r\n\r\n        if (hasCallback) {\r\n            request.presign(expires, function(err, url) {\r\n                if (url) {\r\n                    url = self.convertUrlToAuthToken(url);\r\n                }\r\n                callback(err, url);\r\n            });\r\n        } else {\r\n            var url = request.presign(expires);\r\n            return this.convertUrlToAuthToken(url);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Modifies a request to allow the presigner to generate an auth token.\r\n     */\r\n    modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\r\n        request.on('build', request.buildAsGet);\r\n        var httpRequest = request.httpRequest;\r\n        httpRequest.body = AWS.util.queryParamsToString({\r\n            Action: 'connect',\r\n            DBUser: options.username\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Validates that the options passed in contain all the keys with values of the correct type that\r\n     *   are needed to generate an auth token.\r\n     */\r\n    validateAuthTokenOptions: function validateAuthTokenOptions(options) {\r\n        // iterate over all keys in options\r\n        var message = '';\r\n        options = options || {};\r\n        for (var key in requiredAuthTokenOptions) {\r\n            if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\r\n                continue;\r\n            }\r\n            if (typeof options[key] !== requiredAuthTokenOptions[key]) {\r\n                message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\r\n            }\r\n        }\r\n        if (message.length) {\r\n            return AWS.util.error(new Error(), {\r\n                code: 'InvalidParameter',\r\n                message: message\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"script"}