{"ast":null,"code":"var util = require('../core').util;\n\nvar toBuffer = util.buffer.toBuffer;\n/**\r\n * A lossless representation of a signed, 64-bit integer. Instances of this\r\n * class may be used in arithmetic expressions as if they were numeric\r\n * primitives, but the binary representation will be preserved unchanged as the\r\n * `bytes` property of the object. The bytes should be encoded as big-endian,\r\n * two's complement integers.\r\n * @param {Buffer} bytes\r\n *\r\n * @api private\r\n */\n\nfunction Int64(bytes) {\n  if (bytes.length !== 8) {\n    throw new Error('Int64 buffers must be exactly 8 bytes');\n  }\n\n  if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);\n  this.bytes = bytes;\n}\n/**\r\n * @param {number} number\r\n * @returns {Int64}\r\n *\r\n * @api private\r\n */\n\n\nInt64.fromNumber = function (number) {\n  if (number > 9223372036854775807 || number < -9223372036854775808) {\n    throw new Error(number + ' is too large (or, if negative, too small) to represent as an Int64');\n  }\n\n  var bytes = new Uint8Array(8);\n\n  for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n    bytes[i] = remaining;\n  }\n\n  if (number < 0) {\n    negate(bytes);\n  }\n\n  return new Int64(bytes);\n};\n/**\r\n * @returns {number}\r\n *\r\n * @api private\r\n */\n\n\nInt64.prototype.valueOf = function () {\n  var bytes = this.bytes.slice(0);\n  var negative = bytes[0] & 128;\n\n  if (negative) {\n    negate(bytes);\n  }\n\n  return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);\n};\n\nInt64.prototype.toString = function () {\n  return String(this.valueOf());\n};\n/**\r\n * @param {Buffer} bytes\r\n *\r\n * @api private\r\n */\n\n\nfunction negate(bytes) {\n  for (var i = 0; i < 8; i++) {\n    bytes[i] ^= 0xFF;\n  }\n\n  for (var i = 7; i > -1; i--) {\n    bytes[i]++;\n\n    if (bytes[i] !== 0) {\n      break;\n    }\n  }\n}\n/**\r\n * @api private\r\n */\n\n\nmodule.exports = {\n  Int64: Int64\n};","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/event-stream/int64.js"],"names":["util","require","toBuffer","buffer","Int64","bytes","length","Error","Buffer","isBuffer","fromNumber","number","Uint8Array","i","remaining","Math","abs","round","negate","prototype","valueOf","slice","negative","parseInt","toString","String","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,IAA9B;;AACA,IAAIE,QAAQ,GAAGF,IAAI,CAACG,MAAL,CAAYD,QAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,KAAT,CAAeC,KAAf,EAAsB;AAClB,MAAIA,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACH;;AACD,MAAI,CAACP,IAAI,CAACQ,MAAL,CAAYC,QAAZ,CAAqBJ,KAArB,CAAL,EAAkCA,KAAK,GAAGH,QAAQ,CAACG,KAAD,CAAhB;AAElC,OAAKA,KAAL,GAAaA,KAAb;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAD,KAAK,CAACM,UAAN,GAAmB,UAASC,MAAT,EAAiB;AAChC,MAAIA,MAAM,GAAG,mBAAT,IAAgCA,MAAM,GAAG,CAAC,mBAA9C,EAAmE;AAC/D,UAAM,IAAIJ,KAAJ,CACFI,MAAM,GAAG,qEADP,CAAN;AAGH;;AAED,MAAIN,KAAK,GAAG,IAAIO,UAAJ,CAAe,CAAf,CAAZ;;AACA,OACI,IAAIC,CAAC,GAAG,CAAR,EAAWC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWN,MAAX,CAAT,CAD3B,EAEIE,CAAC,GAAG,CAAC,CAAL,IAAUC,SAAS,GAAG,CAF1B,EAGID,CAAC,IAAIC,SAAS,IAAI,GAHtB,EAIE;AACET,IAAAA,KAAK,CAACQ,CAAD,CAAL,GAAWC,SAAX;AACH;;AAED,MAAIH,MAAM,GAAG,CAAb,EAAgB;AACZO,IAAAA,MAAM,CAACb,KAAD,CAAN;AACH;;AAED,SAAO,IAAID,KAAJ,CAAUC,KAAV,CAAP;AACH,CArBD;AAuBA;AACA;AACA;AACA;AACA;;;AACAD,KAAK,CAACe,SAAN,CAAgBC,OAAhB,GAA0B,YAAW;AACjC,MAAIf,KAAK,GAAG,KAAKA,KAAL,CAAWgB,KAAX,CAAiB,CAAjB,CAAZ;AACA,MAAIC,QAAQ,GAAGjB,KAAK,CAAC,CAAD,CAAL,GAAW,GAA1B;;AACA,MAAIiB,QAAJ,EAAc;AACVJ,IAAAA,MAAM,CAACb,KAAD,CAAN;AACH;;AAED,SAAOkB,QAAQ,CAAClB,KAAK,CAACmB,QAAN,CAAe,KAAf,CAAD,EAAwB,EAAxB,CAAR,IAAuCF,QAAQ,GAAG,CAAC,CAAJ,GAAQ,CAAvD,CAAP;AACH,CARD;;AAUAlB,KAAK,CAACe,SAAN,CAAgBK,QAAhB,GAA2B,YAAW;AAClC,SAAOC,MAAM,CAAC,KAAKL,OAAL,EAAD,CAAb;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA,SAASF,MAAT,CAAgBb,KAAhB,EAAuB;AACnB,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxBR,IAAAA,KAAK,CAACQ,CAAD,CAAL,IAAY,IAAZ;AACH;;AACD,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAAC,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AACzBR,IAAAA,KAAK,CAACQ,CAAD,CAAL;;AACA,QAAIR,KAAK,CAACQ,CAAD,CAAL,KAAa,CAAjB,EAAoB;AAChB;AACH;AACJ;AACJ;AAED;AACA;AACA;;;AACAa,MAAM,CAACC,OAAP,GAAiB;AACbvB,EAAAA,KAAK,EAAEA;AADM,CAAjB","sourcesContent":["var util = require('../core').util;\r\nvar toBuffer = util.buffer.toBuffer;\r\n\r\n/**\r\n * A lossless representation of a signed, 64-bit integer. Instances of this\r\n * class may be used in arithmetic expressions as if they were numeric\r\n * primitives, but the binary representation will be preserved unchanged as the\r\n * `bytes` property of the object. The bytes should be encoded as big-endian,\r\n * two's complement integers.\r\n * @param {Buffer} bytes\r\n *\r\n * @api private\r\n */\r\nfunction Int64(bytes) {\r\n    if (bytes.length !== 8) {\r\n        throw new Error('Int64 buffers must be exactly 8 bytes');\r\n    }\r\n    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);\r\n\r\n    this.bytes = bytes;\r\n}\r\n\r\n/**\r\n * @param {number} number\r\n * @returns {Int64}\r\n *\r\n * @api private\r\n */\r\nInt64.fromNumber = function(number) {\r\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\r\n        throw new Error(\r\n            number + ' is too large (or, if negative, too small) to represent as an Int64'\r\n        );\r\n    }\r\n\r\n    var bytes = new Uint8Array(8);\r\n    for (\r\n        var i = 7, remaining = Math.abs(Math.round(number));\r\n        i > -1 && remaining > 0;\r\n        i--, remaining /= 256\r\n    ) {\r\n        bytes[i] = remaining;\r\n    }\r\n\r\n    if (number < 0) {\r\n        negate(bytes);\r\n    }\r\n\r\n    return new Int64(bytes);\r\n};\r\n\r\n/**\r\n * @returns {number}\r\n *\r\n * @api private\r\n */\r\nInt64.prototype.valueOf = function() {\r\n    var bytes = this.bytes.slice(0);\r\n    var negative = bytes[0] & 128;\r\n    if (negative) {\r\n        negate(bytes);\r\n    }\r\n\r\n    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);\r\n};\r\n\r\nInt64.prototype.toString = function() {\r\n    return String(this.valueOf());\r\n};\r\n\r\n/**\r\n * @param {Buffer} bytes\r\n *\r\n * @api private\r\n */\r\nfunction negate(bytes) {\r\n    for (var i = 0; i < 8; i++) {\r\n        bytes[i] ^= 0xFF;\r\n    }\r\n    for (var i = 7; i > -1; i--) {\r\n        bytes[i]++;\r\n        if (bytes[i] !== 0) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = {\r\n    Int64: Int64\r\n};\r\n"]},"metadata":{},"sourceType":"script"}