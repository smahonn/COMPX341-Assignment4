{"ast":null,"code":"var AWS = require('../core'),\n    url = AWS.util.url,\n    crypto = AWS.util.crypto.lib,\n    base64Encode = AWS.util.base64.encode,\n    inherit = AWS.util.inherit;\n\nvar queryEncode = function queryEncode(string) {\n  var replacements = {\n    '+': '-',\n    '=': '_',\n    '/': '~'\n  };\n  return string.replace(/[\\+=\\/]/g, function (match) {\n    return replacements[match];\n  });\n};\n\nvar signPolicy = function signPolicy(policy, privateKey) {\n  var sign = crypto.createSign('RSA-SHA1');\n  sign.write(policy);\n  return queryEncode(sign.sign(privateKey, 'base64'));\n};\n\nvar signWithCannedPolicy = function signWithCannedPolicy(url, expires, keyPairId, privateKey) {\n  var policy = JSON.stringify({\n    Statement: [{\n      Resource: url,\n      Condition: {\n        DateLessThan: {\n          'AWS:EpochTime': expires\n        }\n      }\n    }]\n  });\n  return {\n    Expires: expires,\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy.toString(), privateKey)\n  };\n};\n\nvar signWithCustomPolicy = function signWithCustomPolicy(policy, keyPairId, privateKey) {\n  policy = policy.replace(/\\s/mg, '');\n  return {\n    Policy: queryEncode(base64Encode(policy)),\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy, privateKey)\n  };\n};\n\nvar determineScheme = function determineScheme(url) {\n  var parts = url.split('://');\n\n  if (parts.length < 2) {\n    throw new Error('Invalid URL.');\n  }\n\n  return parts[0].replace('*', '');\n};\n\nvar getRtmpUrl = function getRtmpUrl(rtmpUrl) {\n  var parsed = url.parse(rtmpUrl);\n  return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\n};\n\nvar getResource = function getResource(url) {\n  switch (determineScheme(url)) {\n    case 'http':\n    case 'https':\n      return url;\n\n    case 'rtmp':\n      return getRtmpUrl(url);\n\n    default:\n      throw new Error('Invalid URI scheme. Scheme must be one of' + ' http, https, or rtmp');\n  }\n};\n\nvar handleError = function handleError(err, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw err;\n  }\n\n  callback(err);\n};\n\nvar handleSuccess = function handleSuccess(result, callback) {\n  if (!callback || typeof callback !== 'function') {\n    return result;\n  }\n\n  callback(null, result);\n};\n\nAWS.CloudFront.Signer = inherit({\n  /**\r\n   * A signer object can be used to generate signed URLs and cookies for granting\r\n   * access to content on restricted CloudFront distributions.\r\n   *\r\n   * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\r\n   *\r\n   * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\r\n   *                              being used.\r\n   * @param privateKey [String]   (Required) A private key in RSA format.\r\n   */\n  constructor: function Signer(keyPairId, privateKey) {\n    if (keyPairId === void 0 || privateKey === void 0) {\n      throw new Error('A key pair ID and private key are required');\n    }\n\n    this.keyPairId = keyPairId;\n    this.privateKey = privateKey;\n  },\n\n  /**\r\n   * Create a signed Amazon CloudFront Cookie.\r\n   *\r\n   * @param options [Object]            The options to create a signed cookie.\r\n   * @option options url [String]     The URL to which the signature will grant\r\n   *                                  access. Required unless you pass in a full\r\n   *                                  policy.\r\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n   *                                  signature should expire. Required unless you\r\n   *                                  pass in a full policy.\r\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n   *                                  you pass in a url and an expiry time.\r\n   *\r\n   * @param cb [Function] if a callback is provided, this function will\r\n   *   pass the hash as the second parameter (after the error parameter) to\r\n   *   the callback function.\r\n   *\r\n   * @return [Object] if called synchronously (with no callback), returns the\r\n   *   signed cookie parameters.\r\n   * @return [null] nothing is returned if a callback is provided.\r\n   */\n  getSignedCookie: function getSignedCookie(options, cb) {\n    var signatureHash = 'policy' in options ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\n    var cookieHash = {};\n\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        cookieHash['CloudFront-' + key] = signatureHash[key];\n      }\n    }\n\n    return handleSuccess(cookieHash, cb);\n  },\n\n  /**\r\n   * Create a signed Amazon CloudFront URL.\r\n   *\r\n   * Keep in mind that URLs meant for use in media/flash players may have\r\n   * different requirements for URL formats (e.g. some require that the\r\n   * extension be removed, some require the file name to be prefixed\r\n   * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\r\n   *\r\n   * @param options [Object]          The options to create a signed URL.\r\n   * @option options url [String]     The URL to which the signature will grant\r\n   *                                  access. Any query params included with\r\n   *                                  the URL should be encoded. Required.\r\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n   *                                  signature should expire. Required unless you\r\n   *                                  pass in a full policy.\r\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n   *                                  you pass in a url and an expiry time.\r\n   *\r\n   * @param cb [Function] if a callback is provided, this function will\r\n   *   pass the URL as the second parameter (after the error parameter) to\r\n   *   the callback function.\r\n   *\r\n   * @return [String] if called synchronously (with no callback), returns the\r\n   *   signed URL.\r\n   * @return [null] nothing is returned if a callback is provided.\r\n   */\n  getSignedUrl: function getSignedUrl(options, cb) {\n    try {\n      var resource = getResource(options.url);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n\n    var parsedUrl = url.parse(options.url, true),\n        signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy') ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\n    parsedUrl.search = null;\n\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        parsedUrl.query[key] = signatureHash[key];\n      }\n    }\n\n    try {\n      var signedUrl = determineScheme(options.url) === 'rtmp' ? getRtmpUrl(url.format(parsedUrl)) : url.format(parsedUrl);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n\n    return handleSuccess(signedUrl, cb);\n  }\n});\n/**\r\n * @api private\r\n */\n\nmodule.exports = AWS.CloudFront.Signer;","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/cloudfront/signer.js"],"names":["AWS","require","url","util","crypto","lib","base64Encode","base64","encode","inherit","queryEncode","string","replacements","replace","match","signPolicy","policy","privateKey","sign","createSign","write","signWithCannedPolicy","expires","keyPairId","JSON","stringify","Statement","Resource","Condition","DateLessThan","Expires","Signature","toString","signWithCustomPolicy","Policy","determineScheme","parts","split","length","Error","getRtmpUrl","rtmpUrl","parsed","parse","path","hash","getResource","handleError","err","callback","handleSuccess","result","CloudFront","Signer","constructor","getSignedCookie","options","cb","signatureHash","cookieHash","key","Object","prototype","hasOwnProperty","call","getSignedUrl","resource","parsedUrl","search","query","signedUrl","format","module","exports"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAjB;AAAA,IACIC,GAAG,GAAGF,GAAG,CAACG,IAAJ,CAASD,GADnB;AAAA,IAEIE,MAAM,GAAGJ,GAAG,CAACG,IAAJ,CAASC,MAAT,CAAgBC,GAF7B;AAAA,IAGIC,YAAY,GAAGN,GAAG,CAACG,IAAJ,CAASI,MAAT,CAAgBC,MAHnC;AAAA,IAIIC,OAAO,GAAGT,GAAG,CAACG,IAAJ,CAASM,OAJvB;;AAMA,IAAIC,WAAW,GAAG,SAAdA,WAAc,CAAUC,MAAV,EAAkB;AAChC,MAAIC,YAAY,GAAG;AACf,SAAK,GADU;AAEf,SAAK,GAFU;AAGf,SAAK;AAHU,GAAnB;AAKA,SAAOD,MAAM,CAACE,OAAP,CAAe,UAAf,EAA2B,UAAUC,KAAV,EAAiB;AAC/C,WAAOF,YAAY,CAACE,KAAD,CAAnB;AACH,GAFM,CAAP;AAGH,CATD;;AAWA,IAAIC,UAAU,GAAG,SAAbA,UAAa,CAAUC,MAAV,EAAkBC,UAAlB,EAA8B;AAC3C,MAAIC,IAAI,GAAGd,MAAM,CAACe,UAAP,CAAkB,UAAlB,CAAX;AACAD,EAAAA,IAAI,CAACE,KAAL,CAAWJ,MAAX;AACA,SAAON,WAAW,CAACQ,IAAI,CAACA,IAAL,CAAUD,UAAV,EAAsB,QAAtB,CAAD,CAAlB;AACH,CAJD;;AAMA,IAAII,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAUnB,GAAV,EAAeoB,OAAf,EAAwBC,SAAxB,EAAmCN,UAAnC,EAA+C;AACtE,MAAID,MAAM,GAAGQ,IAAI,CAACC,SAAL,CAAe;AACxBC,IAAAA,SAAS,EAAE,CACP;AACIC,MAAAA,QAAQ,EAAEzB,GADd;AAEI0B,MAAAA,SAAS,EAAE;AAAEC,QAAAA,YAAY,EAAE;AAAE,2BAAiBP;AAAnB;AAAhB;AAFf,KADO;AADa,GAAf,CAAb;AASA,SAAO;AACHQ,IAAAA,OAAO,EAAER,OADN;AAEH,mBAAeC,SAFZ;AAGHQ,IAAAA,SAAS,EAAEhB,UAAU,CAACC,MAAM,CAACgB,QAAP,EAAD,EAAoBf,UAApB;AAHlB,GAAP;AAKH,CAfD;;AAiBA,IAAIgB,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAUjB,MAAV,EAAkBO,SAAlB,EAA6BN,UAA7B,EAAyC;AAChED,EAAAA,MAAM,GAAGA,MAAM,CAACH,OAAP,CAAe,MAAf,EAAuB,EAAvB,CAAT;AAEA,SAAO;AACHqB,IAAAA,MAAM,EAAExB,WAAW,CAACJ,YAAY,CAACU,MAAD,CAAb,CADhB;AAEH,mBAAeO,SAFZ;AAGHQ,IAAAA,SAAS,EAAEhB,UAAU,CAACC,MAAD,EAASC,UAAT;AAHlB,GAAP;AAKH,CARD;;AAUA,IAAIkB,eAAe,GAAG,SAAlBA,eAAkB,CAAUjC,GAAV,EAAe;AACjC,MAAIkC,KAAK,GAAGlC,GAAG,CAACmC,KAAJ,CAAU,KAAV,CAAZ;;AACA,MAAID,KAAK,CAACE,MAAN,GAAe,CAAnB,EAAsB;AAClB,UAAM,IAAIC,KAAJ,CAAU,cAAV,CAAN;AACH;;AAED,SAAOH,KAAK,CAAC,CAAD,CAAL,CAASvB,OAAT,CAAiB,GAAjB,EAAsB,EAAtB,CAAP;AACH,CAPD;;AASA,IAAI2B,UAAU,GAAG,SAAbA,UAAa,CAAUC,OAAV,EAAmB;AAChC,MAAIC,MAAM,GAAGxC,GAAG,CAACyC,KAAJ,CAAUF,OAAV,CAAb;AACA,SAAOC,MAAM,CAACE,IAAP,CAAY/B,OAAZ,CAAoB,KAApB,EAA2B,EAA3B,KAAkC6B,MAAM,CAACG,IAAP,IAAe,EAAjD,CAAP;AACH,CAHD;;AAKA,IAAIC,WAAW,GAAG,SAAdA,WAAc,CAAU5C,GAAV,EAAe;AAC7B,UAAQiC,eAAe,CAACjC,GAAD,CAAvB;AACI,SAAK,MAAL;AACA,SAAK,OAAL;AACI,aAAOA,GAAP;;AACJ,SAAK,MAAL;AACI,aAAOsC,UAAU,CAACtC,GAAD,CAAjB;;AACJ;AACI,YAAM,IAAIqC,KAAJ,CAAU,8CACV,uBADA,CAAN;AAPR;AAUH,CAXD;;AAaA,IAAIQ,WAAW,GAAG,SAAdA,WAAc,CAAUC,GAAV,EAAeC,QAAf,EAAyB;AACvC,MAAI,CAACA,QAAD,IAAa,OAAOA,QAAP,KAAoB,UAArC,EAAiD;AAC7C,UAAMD,GAAN;AACH;;AAEDC,EAAAA,QAAQ,CAACD,GAAD,CAAR;AACH,CAND;;AAQA,IAAIE,aAAa,GAAG,SAAhBA,aAAgB,CAAUC,MAAV,EAAkBF,QAAlB,EAA4B;AAC5C,MAAI,CAACA,QAAD,IAAa,OAAOA,QAAP,KAAoB,UAArC,EAAiD;AAC7C,WAAOE,MAAP;AACH;;AAEDF,EAAAA,QAAQ,CAAC,IAAD,EAAOE,MAAP,CAAR;AACH,CAND;;AAQAnD,GAAG,CAACoD,UAAJ,CAAeC,MAAf,GAAwB5C,OAAO,CAAC;AAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI6C,EAAAA,WAAW,EAAE,SAASD,MAAT,CAAgB9B,SAAhB,EAA2BN,UAA3B,EAAuC;AAChD,QAAIM,SAAS,KAAK,KAAK,CAAnB,IAAwBN,UAAU,KAAK,KAAK,CAAhD,EAAmD;AAC/C,YAAM,IAAIsB,KAAJ,CAAU,4CAAV,CAAN;AACH;;AAED,SAAKhB,SAAL,GAAiBA,SAAjB;AACA,SAAKN,UAAL,GAAkBA,UAAlB;AACH,GAlB2B;;AAoB5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIsC,EAAAA,eAAe,EAAE,yBAAUC,OAAV,EAAmBC,EAAnB,EAAuB;AACpC,QAAIC,aAAa,GAAG,YAAYF,OAAZ,GACdvB,oBAAoB,CAACuB,OAAO,CAACxC,MAAT,EAAiB,KAAKO,SAAtB,EAAiC,KAAKN,UAAtC,CADN,GAEdI,oBAAoB,CAACmC,OAAO,CAACtD,GAAT,EAAcsD,OAAO,CAAClC,OAAtB,EAA+B,KAAKC,SAApC,EAA+C,KAAKN,UAApD,CAF1B;AAIA,QAAI0C,UAAU,GAAG,EAAjB;;AACA,SAAK,IAAIC,GAAT,IAAgBF,aAAhB,EAA+B;AAC3B,UAAIG,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,aAArC,EAAoDE,GAApD,CAAJ,EAA8D;AAC1DD,QAAAA,UAAU,CAAC,gBAAgBC,GAAjB,CAAV,GAAkCF,aAAa,CAACE,GAAD,CAA/C;AACH;AACJ;;AAED,WAAOV,aAAa,CAACS,UAAD,EAAaF,EAAb,CAApB;AACH,GAtD2B;;AAwD5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIQ,EAAAA,YAAY,EAAE,sBAAUT,OAAV,EAAmBC,EAAnB,EAAuB;AACjC,QAAI;AACA,UAAIS,QAAQ,GAAGpB,WAAW,CAACU,OAAO,CAACtD,GAAT,CAA1B;AACH,KAFD,CAEE,OAAO8C,GAAP,EAAY;AACV,aAAOD,WAAW,CAACC,GAAD,EAAMS,EAAN,CAAlB;AACH;;AAED,QAAIU,SAAS,GAAGjE,GAAG,CAACyC,KAAJ,CAAUa,OAAO,CAACtD,GAAlB,EAAuB,IAAvB,CAAhB;AAAA,QACIwD,aAAa,GAAGG,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,OAArC,EAA8C,QAA9C,IACVvB,oBAAoB,CAACuB,OAAO,CAACxC,MAAT,EAAiB,KAAKO,SAAtB,EAAiC,KAAKN,UAAtC,CADV,GAEVI,oBAAoB,CAAC6C,QAAD,EAAWV,OAAO,CAAClC,OAAnB,EAA4B,KAAKC,SAAjC,EAA4C,KAAKN,UAAjD,CAH9B;AAKAkD,IAAAA,SAAS,CAACC,MAAV,GAAmB,IAAnB;;AACA,SAAK,IAAIR,GAAT,IAAgBF,aAAhB,EAA+B;AAC3B,UAAIG,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,aAArC,EAAoDE,GAApD,CAAJ,EAA8D;AAC1DO,QAAAA,SAAS,CAACE,KAAV,CAAgBT,GAAhB,IAAuBF,aAAa,CAACE,GAAD,CAApC;AACH;AACJ;;AAED,QAAI;AACA,UAAIU,SAAS,GAAGnC,eAAe,CAACqB,OAAO,CAACtD,GAAT,CAAf,KAAiC,MAAjC,GACNsC,UAAU,CAACtC,GAAG,CAACqE,MAAJ,CAAWJ,SAAX,CAAD,CADJ,GAENjE,GAAG,CAACqE,MAAJ,CAAWJ,SAAX,CAFV;AAGH,KAJD,CAIE,OAAOnB,GAAP,EAAY;AACV,aAAOD,WAAW,CAACC,GAAD,EAAMS,EAAN,CAAlB;AACH;;AAED,WAAOP,aAAa,CAACoB,SAAD,EAAYb,EAAZ,CAApB;AACH;AA9G2B,CAAD,CAA/B;AAiHA;AACA;AACA;;AACAe,MAAM,CAACC,OAAP,GAAiBzE,GAAG,CAACoD,UAAJ,CAAeC,MAAhC","sourcesContent":["var AWS = require('../core'),\r\n    url = AWS.util.url,\r\n    crypto = AWS.util.crypto.lib,\r\n    base64Encode = AWS.util.base64.encode,\r\n    inherit = AWS.util.inherit;\r\n\r\nvar queryEncode = function (string) {\r\n    var replacements = {\r\n        '+': '-',\r\n        '=': '_',\r\n        '/': '~'\r\n    };\r\n    return string.replace(/[\\+=\\/]/g, function (match) {\r\n        return replacements[match];\r\n    });\r\n};\r\n\r\nvar signPolicy = function (policy, privateKey) {\r\n    var sign = crypto.createSign('RSA-SHA1');\r\n    sign.write(policy);\r\n    return queryEncode(sign.sign(privateKey, 'base64'));\r\n};\r\n\r\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\r\n    var policy = JSON.stringify({\r\n        Statement: [\r\n            {\r\n                Resource: url,\r\n                Condition: { DateLessThan: { 'AWS:EpochTime': expires } }\r\n            }\r\n        ]\r\n    });\r\n\r\n    return {\r\n        Expires: expires,\r\n        'Key-Pair-Id': keyPairId,\r\n        Signature: signPolicy(policy.toString(), privateKey)\r\n    };\r\n};\r\n\r\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\r\n    policy = policy.replace(/\\s/mg, '');\r\n\r\n    return {\r\n        Policy: queryEncode(base64Encode(policy)),\r\n        'Key-Pair-Id': keyPairId,\r\n        Signature: signPolicy(policy, privateKey)\r\n    };\r\n};\r\n\r\nvar determineScheme = function (url) {\r\n    var parts = url.split('://');\r\n    if (parts.length < 2) {\r\n        throw new Error('Invalid URL.');\r\n    }\r\n\r\n    return parts[0].replace('*', '');\r\n};\r\n\r\nvar getRtmpUrl = function (rtmpUrl) {\r\n    var parsed = url.parse(rtmpUrl);\r\n    return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\r\n};\r\n\r\nvar getResource = function (url) {\r\n    switch (determineScheme(url)) {\r\n        case 'http':\r\n        case 'https':\r\n            return url;\r\n        case 'rtmp':\r\n            return getRtmpUrl(url);\r\n        default:\r\n            throw new Error('Invalid URI scheme. Scheme must be one of'\r\n                + ' http, https, or rtmp');\r\n    }\r\n};\r\n\r\nvar handleError = function (err, callback) {\r\n    if (!callback || typeof callback !== 'function') {\r\n        throw err;\r\n    }\r\n\r\n    callback(err);\r\n};\r\n\r\nvar handleSuccess = function (result, callback) {\r\n    if (!callback || typeof callback !== 'function') {\r\n        return result;\r\n    }\r\n\r\n    callback(null, result);\r\n};\r\n\r\nAWS.CloudFront.Signer = inherit({\r\n    /**\r\n     * A signer object can be used to generate signed URLs and cookies for granting\r\n     * access to content on restricted CloudFront distributions.\r\n     *\r\n     * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\r\n     *\r\n     * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\r\n     *                              being used.\r\n     * @param privateKey [String]   (Required) A private key in RSA format.\r\n     */\r\n    constructor: function Signer(keyPairId, privateKey) {\r\n        if (keyPairId === void 0 || privateKey === void 0) {\r\n            throw new Error('A key pair ID and private key are required');\r\n        }\r\n\r\n        this.keyPairId = keyPairId;\r\n        this.privateKey = privateKey;\r\n    },\r\n\r\n    /**\r\n     * Create a signed Amazon CloudFront Cookie.\r\n     *\r\n     * @param options [Object]            The options to create a signed cookie.\r\n     * @option options url [String]     The URL to which the signature will grant\r\n     *                                  access. Required unless you pass in a full\r\n     *                                  policy.\r\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n     *                                  signature should expire. Required unless you\r\n     *                                  pass in a full policy.\r\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n     *                                  you pass in a url and an expiry time.\r\n     *\r\n     * @param cb [Function] if a callback is provided, this function will\r\n     *   pass the hash as the second parameter (after the error parameter) to\r\n     *   the callback function.\r\n     *\r\n     * @return [Object] if called synchronously (with no callback), returns the\r\n     *   signed cookie parameters.\r\n     * @return [null] nothing is returned if a callback is provided.\r\n     */\r\n    getSignedCookie: function (options, cb) {\r\n        var signatureHash = 'policy' in options\r\n            ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\r\n            : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\r\n\r\n        var cookieHash = {};\r\n        for (var key in signatureHash) {\r\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\r\n                cookieHash['CloudFront-' + key] = signatureHash[key];\r\n            }\r\n        }\r\n\r\n        return handleSuccess(cookieHash, cb);\r\n    },\r\n\r\n    /**\r\n     * Create a signed Amazon CloudFront URL.\r\n     *\r\n     * Keep in mind that URLs meant for use in media/flash players may have\r\n     * different requirements for URL formats (e.g. some require that the\r\n     * extension be removed, some require the file name to be prefixed\r\n     * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\r\n     *\r\n     * @param options [Object]          The options to create a signed URL.\r\n     * @option options url [String]     The URL to which the signature will grant\r\n     *                                  access. Any query params included with\r\n     *                                  the URL should be encoded. Required.\r\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n     *                                  signature should expire. Required unless you\r\n     *                                  pass in a full policy.\r\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n     *                                  you pass in a url and an expiry time.\r\n     *\r\n     * @param cb [Function] if a callback is provided, this function will\r\n     *   pass the URL as the second parameter (after the error parameter) to\r\n     *   the callback function.\r\n     *\r\n     * @return [String] if called synchronously (with no callback), returns the\r\n     *   signed URL.\r\n     * @return [null] nothing is returned if a callback is provided.\r\n     */\r\n    getSignedUrl: function (options, cb) {\r\n        try {\r\n            var resource = getResource(options.url);\r\n        } catch (err) {\r\n            return handleError(err, cb);\r\n        }\r\n\r\n        var parsedUrl = url.parse(options.url, true),\r\n            signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy')\r\n                ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\r\n                : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\r\n\r\n        parsedUrl.search = null;\r\n        for (var key in signatureHash) {\r\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\r\n                parsedUrl.query[key] = signatureHash[key];\r\n            }\r\n        }\r\n\r\n        try {\r\n            var signedUrl = determineScheme(options.url) === 'rtmp'\r\n                    ? getRtmpUrl(url.format(parsedUrl))\r\n                    : url.format(parsedUrl);\r\n        } catch (err) {\r\n            return handleError(err, cb);\r\n        }\r\n\r\n        return handleSuccess(signedUrl, cb);\r\n    }\r\n});\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = AWS.CloudFront.Signer;\r\n"]},"metadata":{},"sourceType":"script"}