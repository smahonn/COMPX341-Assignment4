{"ast":null,"code":"var parseMessage = require('./parse-message').parseMessage;\n/**\r\n *\r\n * @param {*} parser\r\n * @param {Buffer} message\r\n * @param {*} shape\r\n * @api private\r\n */\n\n\nfunction parseEvent(parser, message, shape) {\n  var parsedMessage = parseMessage(message); // check if message is an event or error\n\n  var messageType = parsedMessage.headers[':message-type'];\n\n  if (messageType) {\n    if (messageType.value === 'error') {\n      throw parseError(parsedMessage);\n    } else if (messageType.value !== 'event') {\n      // not sure how to parse non-events/non-errors, ignore for now\n      return;\n    }\n  } // determine event type\n\n\n  var eventType = parsedMessage.headers[':event-type']; // check that the event type is modeled\n\n  var eventModel = shape.members[eventType.value];\n\n  if (!eventModel) {\n    return;\n  }\n\n  var result = {}; // check if an event payload exists\n\n  var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n\n  if (eventPayloadMemberName) {\n    var payloadShape = eventModel.members[eventPayloadMemberName]; // if the shape is binary, return the byte array\n\n    if (payloadShape.type === 'binary') {\n      result[eventPayloadMemberName] = parsedMessage.body;\n    } else {\n      result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n    }\n  } // read event headers\n\n\n  var eventHeaderNames = eventModel.eventHeaderMemberNames;\n\n  for (var i = 0; i < eventHeaderNames.length; i++) {\n    var name = eventHeaderNames[i];\n\n    if (parsedMessage.headers[name]) {\n      // parse the header!\n      result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n    }\n  }\n\n  var output = {};\n  output[eventType.value] = result;\n  return output;\n}\n\nfunction parseError(message) {\n  var errorCode = message.headers[':error-code'];\n  var errorMessage = message.headers[':error-message'];\n  var error = new Error(errorMessage.value || errorMessage);\n  error.code = error.name = errorCode.value || errorCode;\n  return error;\n}\n/**\r\n * @api private\r\n */\n\n\nmodule.exports = {\n  parseEvent: parseEvent\n};","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/event-stream/parse-event.js"],"names":["parseMessage","require","parseEvent","parser","message","shape","parsedMessage","messageType","headers","value","parseError","eventType","eventModel","members","result","eventPayloadMemberName","payloadShape","type","body","parse","toString","eventHeaderNames","eventHeaderMemberNames","i","length","name","toType","output","errorCode","errorMessage","error","Error","code","module","exports"],"mappings":"AAAA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,YAA9C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAoBC,MAApB,EAA4BC,OAA5B,EAAqCC,KAArC,EAA4C;AACxC,MAAIC,aAAa,GAAGN,YAAY,CAACI,OAAD,CAAhC,CADwC,CAGxC;;AACA,MAAIG,WAAW,GAAGD,aAAa,CAACE,OAAd,CAAsB,eAAtB,CAAlB;;AACA,MAAID,WAAJ,EAAiB;AACb,QAAIA,WAAW,CAACE,KAAZ,KAAsB,OAA1B,EAAmC;AAC/B,YAAMC,UAAU,CAACJ,aAAD,CAAhB;AACH,KAFD,MAEO,IAAIC,WAAW,CAACE,KAAZ,KAAsB,OAA1B,EAAmC;AACtC;AACA;AACH;AACJ,GAZuC,CAcxC;;;AACA,MAAIE,SAAS,GAAGL,aAAa,CAACE,OAAd,CAAsB,aAAtB,CAAhB,CAfwC,CAgBxC;;AACA,MAAII,UAAU,GAAGP,KAAK,CAACQ,OAAN,CAAcF,SAAS,CAACF,KAAxB,CAAjB;;AACA,MAAI,CAACG,UAAL,EAAiB;AACb;AACH;;AAED,MAAIE,MAAM,GAAG,EAAb,CAtBwC,CAuBxC;;AACA,MAAIC,sBAAsB,GAAGH,UAAU,CAACG,sBAAxC;;AACA,MAAIA,sBAAJ,EAA4B;AACxB,QAAIC,YAAY,GAAGJ,UAAU,CAACC,OAAX,CAAmBE,sBAAnB,CAAnB,CADwB,CAExB;;AACA,QAAIC,YAAY,CAACC,IAAb,KAAsB,QAA1B,EAAoC;AAChCH,MAAAA,MAAM,CAACC,sBAAD,CAAN,GAAiCT,aAAa,CAACY,IAA/C;AACH,KAFD,MAEO;AACHJ,MAAAA,MAAM,CAACC,sBAAD,CAAN,GAAiCZ,MAAM,CAACgB,KAAP,CAAab,aAAa,CAACY,IAAd,CAAmBE,QAAnB,EAAb,EAA4CJ,YAA5C,CAAjC;AACH;AACJ,GAjCuC,CAmCxC;;;AACA,MAAIK,gBAAgB,GAAGT,UAAU,CAACU,sBAAlC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAAgB,CAACG,MAArC,EAA6CD,CAAC,EAA9C,EAAkD;AAC9C,QAAIE,IAAI,GAAGJ,gBAAgB,CAACE,CAAD,CAA3B;;AACA,QAAIjB,aAAa,CAACE,OAAd,CAAsBiB,IAAtB,CAAJ,EAAiC;AAC7B;AACAX,MAAAA,MAAM,CAACW,IAAD,CAAN,GAAeb,UAAU,CAACC,OAAX,CAAmBY,IAAnB,EAAyBC,MAAzB,CAAgCpB,aAAa,CAACE,OAAd,CAAsBiB,IAAtB,EAA4BhB,KAA5D,CAAf;AACH;AACJ;;AAED,MAAIkB,MAAM,GAAG,EAAb;AACAA,EAAAA,MAAM,CAAChB,SAAS,CAACF,KAAX,CAAN,GAA0BK,MAA1B;AACA,SAAOa,MAAP;AACH;;AAED,SAASjB,UAAT,CAAoBN,OAApB,EAA6B;AACzB,MAAIwB,SAAS,GAAGxB,OAAO,CAACI,OAAR,CAAgB,aAAhB,CAAhB;AACA,MAAIqB,YAAY,GAAGzB,OAAO,CAACI,OAAR,CAAgB,gBAAhB,CAAnB;AACA,MAAIsB,KAAK,GAAG,IAAIC,KAAJ,CAAUF,YAAY,CAACpB,KAAb,IAAsBoB,YAAhC,CAAZ;AACAC,EAAAA,KAAK,CAACE,IAAN,GAAaF,KAAK,CAACL,IAAN,GAAaG,SAAS,CAACnB,KAAV,IAAmBmB,SAA7C;AACA,SAAOE,KAAP;AACH;AAED;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiB;AACbhC,EAAAA,UAAU,EAAEA;AADC,CAAjB","sourcesContent":["var parseMessage = require('./parse-message').parseMessage;\r\n\r\n/**\r\n *\r\n * @param {*} parser\r\n * @param {Buffer} message\r\n * @param {*} shape\r\n * @api private\r\n */\r\nfunction parseEvent(parser, message, shape) {\r\n    var parsedMessage = parseMessage(message);\r\n\r\n    // check if message is an event or error\r\n    var messageType = parsedMessage.headers[':message-type'];\r\n    if (messageType) {\r\n        if (messageType.value === 'error') {\r\n            throw parseError(parsedMessage);\r\n        } else if (messageType.value !== 'event') {\r\n            // not sure how to parse non-events/non-errors, ignore for now\r\n            return;\r\n        }\r\n    }\r\n\r\n    // determine event type\r\n    var eventType = parsedMessage.headers[':event-type'];\r\n    // check that the event type is modeled\r\n    var eventModel = shape.members[eventType.value];\r\n    if (!eventModel) {\r\n        return;\r\n    }\r\n\r\n    var result = {};\r\n    // check if an event payload exists\r\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\r\n    if (eventPayloadMemberName) {\r\n        var payloadShape = eventModel.members[eventPayloadMemberName];\r\n        // if the shape is binary, return the byte array\r\n        if (payloadShape.type === 'binary') {\r\n            result[eventPayloadMemberName] = parsedMessage.body;\r\n        } else {\r\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\r\n        }\r\n    }\r\n\r\n    // read event headers\r\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\r\n    for (var i = 0; i < eventHeaderNames.length; i++) {\r\n        var name = eventHeaderNames[i];\r\n        if (parsedMessage.headers[name]) {\r\n            // parse the header!\r\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\r\n        }\r\n    }\r\n\r\n    var output = {};\r\n    output[eventType.value] = result;\r\n    return output;\r\n}\r\n\r\nfunction parseError(message) {\r\n    var errorCode = message.headers[':error-code'];\r\n    var errorMessage = message.headers[':error-message'];\r\n    var error = new Error(errorMessage.value || errorMessage);\r\n    error.code = error.name = errorCode.value || errorCode;\r\n    return error;\r\n}\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = {\r\n    parseEvent: parseEvent\r\n};\r\n"]},"metadata":{},"sourceType":"script"}