{"ast":null,"code":"import { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(geometry.Polygon);\n}\n/**\r\n * Organizes blocks from Rekognition API to each of the categories and and structures\r\n * their data accordingly.\r\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\r\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\r\n */\n\n\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // We categorize each block by running a forEach loop through them.\n\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  }); // remove trailing space of fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\r\n * Organizes blocks from Textract API to each of the categories and and structures\r\n * their data accordingly.\r\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\r\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\r\n */\n\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\n  if (blocks.length === 0) return response;\n  /**\r\n   * We categorize each of the blocks by running a forEach loop through them.\r\n   *\r\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\r\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\r\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\r\n   *\r\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\r\n   * block except the Page block.\r\n   */\n\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n\n      default:\n        blockMap[block.Id] = block;\n    }\n  }); // remove trailing space in fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1); // Post-process complex structures if they exist.\n\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n\n  return response;\n}\n/**\r\n * Constructs a table object using data from its children cells.\r\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\n\nexport function constructTable(table, blockMap) {\n  var tableMatrix;\n  tableMatrix = []; // visit each of the cell associated with the table's relationship.\n\n  table.Relationships.forEach(function (tableRelation) {\n    tableRelation.Ids.forEach(function (cellId) {\n      var cellBlock = blockMap[cellId];\n      var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\n      var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      // extract data contained inside the cell.\n\n      var content = extractContentsFromBlock(cellBlock, blockMap);\n      var cell = {\n        text: content.text,\n        boundingBox: getBoundingBox(cellBlock.Geometry),\n        polygon: getPolygon(cellBlock.Geometry),\n        selected: content.selected,\n        rowSpan: cellBlock.RowSpan,\n        columnSpan: cellBlock.ColumnSpan\n      };\n      if (!tableMatrix[row]) tableMatrix[row] = [];\n      tableMatrix[row][col] = cell;\n    });\n  });\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length; // Note that we leave spanned cells undefined for distinction\n\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\r\n * Constructs a key value object from its children key and value blocks.\r\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\n\nexport function constructKeyValue(keyBlock, blockMap) {\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n  keyBlock.Relationships.forEach(function (keyValueRelation) {\n    if (keyValueRelation.Type === 'CHILD') {\n      // relation refers to key\n      var contents = extractContentsFromBlock(keyBlock, blockMap);\n      keyText = contents.text;\n    } else if (keyValueRelation.Type === 'VALUE') {\n      // relation refers to value\n      keyValueRelation.Ids.forEach(function (valueId) {\n        var valueBlock = blockMap[valueId];\n        var contents = extractContentsFromBlock(valueBlock, blockMap);\n        valueText = contents.text;\n        if (contents.selected != null) valueSelected = contents.selected;\n      });\n    }\n  });\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\r\n * Extracts text and selection from input block's children.\r\n * @param {Textract.Block}} block - Block that we want to extract contents from.\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\n\nexport function extractContentsFromBlock(block, blockMap) {\n  var words = '';\n  var isSelected;\n\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n\n  block.Relationships.forEach(function (relation) {\n    relation.Ids.forEach(function (contentId) {\n      var contentBlock = blockMap[contentId];\n\n      if (contentBlock.BlockType === 'WORD') {\n        words += contentBlock.Text + ' ';\n      } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n        isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n      }\n    });\n  });\n  words = words.substr(0, words.length - 1); // remove trailing space.\n\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"sources":["../../src/Providers/IdentifyTextUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { makeCamelCaseArray, makeCamelCase } from './Utils';\r\nfunction getBoundingBox(geometry) {\r\n    if (!geometry)\r\n        return undefined;\r\n    return makeCamelCase(geometry.BoundingBox);\r\n}\r\nfunction getPolygon(geometry) {\r\n    if (!geometry)\r\n        return undefined;\r\n    return makeCamelCaseArray(geometry.Polygon);\r\n}\r\n/**\r\n * Organizes blocks from Rekognition API to each of the categories and and structures\r\n * their data accordingly.\r\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\r\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\r\n */\r\nexport function categorizeRekognitionBlocks(blocks) {\r\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\r\n    var response = {\r\n        text: {\r\n            fullText: '',\r\n            words: [],\r\n            lines: [],\r\n            linesDetailed: [],\r\n        },\r\n    };\r\n    // We categorize each block by running a forEach loop through them.\r\n    blocks.forEach(function (block) {\r\n        switch (block.Type) {\r\n            case 'LINE':\r\n                response.text.lines.push(block.DetectedText);\r\n                response.text.linesDetailed.push({\r\n                    text: block.DetectedText,\r\n                    polygon: getPolygon(block.Geometry),\r\n                    boundingBox: getBoundingBox(block.Geometry),\r\n                    page: null,\r\n                });\r\n                break;\r\n            case 'WORD':\r\n                response.text.fullText += block.DetectedText + ' ';\r\n                response.text.words.push({\r\n                    text: block.DetectedText,\r\n                    polygon: getPolygon(block.Geometry),\r\n                    boundingBox: getBoundingBox(block.Geometry),\r\n                });\r\n                break;\r\n        }\r\n    });\r\n    // remove trailing space of fullText\r\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\r\n    return response;\r\n}\r\n/**\r\n * Organizes blocks from Textract API to each of the categories and and structures\r\n * their data accordingly.\r\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\r\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\r\n */\r\nexport function categorizeTextractBlocks(blocks) {\r\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\r\n    var response = {\r\n        text: {\r\n            fullText: '',\r\n            words: [],\r\n            lines: [],\r\n            linesDetailed: [],\r\n        },\r\n    };\r\n    // if blocks is an empty array, ie. textract did not detect anything, return empty response.\r\n    if (blocks.length === 0)\r\n        return response;\r\n    /**\r\n     * We categorize each of the blocks by running a forEach loop through them.\r\n     *\r\n     * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\r\n     * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\r\n     * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\r\n     *\r\n     * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\r\n     * block except the Page block.\r\n     */\r\n    var tableBlocks = Array();\r\n    var keyValueBlocks = Array();\r\n    var blockMap = {};\r\n    blocks.forEach(function (block) {\r\n        switch (block.BlockType) {\r\n            case 'LINE':\r\n                response.text.lines.push(block.Text);\r\n                response.text.linesDetailed.push({\r\n                    text: block.Text,\r\n                    polygon: getPolygon(block.Geometry),\r\n                    boundingBox: getBoundingBox(block.Geometry),\r\n                    page: block.Page,\r\n                });\r\n                break;\r\n            case 'WORD':\r\n                response.text.fullText += block.Text + ' ';\r\n                response.text.words.push({\r\n                    text: block.Text,\r\n                    polygon: getPolygon(block.Geometry),\r\n                    boundingBox: getBoundingBox(block.Geometry),\r\n                });\r\n                blockMap[block.Id] = block;\r\n                break;\r\n            case 'SELECTION_ELEMENT':\r\n                var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\r\n                if (!response.text.selections)\r\n                    response.text.selections = [];\r\n                response.text.selections.push({\r\n                    selected: selectionStatus,\r\n                    polygon: getPolygon(block.Geometry),\r\n                    boundingBox: getBoundingBox(block.Geometry),\r\n                });\r\n                blockMap[block.Id] = block;\r\n                break;\r\n            case 'TABLE':\r\n                tableBlocks.push(block);\r\n                break;\r\n            case 'KEY_VALUE_SET':\r\n                keyValueBlocks.push(block);\r\n                blockMap[block.Id] = block;\r\n                break;\r\n            default:\r\n                blockMap[block.Id] = block;\r\n        }\r\n    });\r\n    // remove trailing space in fullText\r\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\r\n    // Post-process complex structures if they exist.\r\n    if (tableBlocks.length !== 0) {\r\n        var tableResponse_1 = Array();\r\n        tableBlocks.forEach(function (table) {\r\n            tableResponse_1.push(constructTable(table, blockMap));\r\n        });\r\n        response.text.tables = tableResponse_1;\r\n    }\r\n    if (keyValueBlocks.length !== 0) {\r\n        var keyValueResponse_1 = Array();\r\n        keyValueBlocks.forEach(function (keyValue) {\r\n            // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\r\n            if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\r\n                keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\r\n            }\r\n        });\r\n        response.text.keyValues = keyValueResponse_1;\r\n    }\r\n    return response;\r\n}\r\n/**\r\n * Constructs a table object using data from its children cells.\r\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\r\nexport function constructTable(table, blockMap) {\r\n    var tableMatrix;\r\n    tableMatrix = [];\r\n    // visit each of the cell associated with the table's relationship.\r\n    table.Relationships.forEach(function (tableRelation) {\r\n        tableRelation.Ids.forEach(function (cellId) {\r\n            var cellBlock = blockMap[cellId];\r\n            var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\r\n            var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\r\n            // extract data contained inside the cell.\r\n            var content = extractContentsFromBlock(cellBlock, blockMap);\r\n            var cell = {\r\n                text: content.text,\r\n                boundingBox: getBoundingBox(cellBlock.Geometry),\r\n                polygon: getPolygon(cellBlock.Geometry),\r\n                selected: content.selected,\r\n                rowSpan: cellBlock.RowSpan,\r\n                columnSpan: cellBlock.ColumnSpan,\r\n            };\r\n            if (!tableMatrix[row])\r\n                tableMatrix[row] = [];\r\n            tableMatrix[row][col] = cell;\r\n        });\r\n    });\r\n    var rowSize = tableMatrix.length;\r\n    var columnSize = tableMatrix[0].length;\r\n    // Note that we leave spanned cells undefined for distinction\r\n    return {\r\n        size: { rows: rowSize, columns: columnSize },\r\n        table: tableMatrix,\r\n        boundingBox: getBoundingBox(table.Geometry),\r\n        polygon: getPolygon(table.Geometry),\r\n    };\r\n}\r\n/**\r\n * Constructs a key value object from its children key and value blocks.\r\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\r\nexport function constructKeyValue(keyBlock, blockMap) {\r\n    var keyText = '';\r\n    var valueText = '';\r\n    var valueSelected;\r\n    keyBlock.Relationships.forEach(function (keyValueRelation) {\r\n        if (keyValueRelation.Type === 'CHILD') {\r\n            // relation refers to key\r\n            var contents = extractContentsFromBlock(keyBlock, blockMap);\r\n            keyText = contents.text;\r\n        }\r\n        else if (keyValueRelation.Type === 'VALUE') {\r\n            // relation refers to value\r\n            keyValueRelation.Ids.forEach(function (valueId) {\r\n                var valueBlock = blockMap[valueId];\r\n                var contents = extractContentsFromBlock(valueBlock, blockMap);\r\n                valueText = contents.text;\r\n                if (contents.selected != null)\r\n                    valueSelected = contents.selected;\r\n            });\r\n        }\r\n    });\r\n    return {\r\n        key: keyText,\r\n        value: { text: valueText, selected: valueSelected },\r\n        polygon: getPolygon(keyBlock.Geometry),\r\n        boundingBox: getBoundingBox(keyBlock.Geometry),\r\n    };\r\n}\r\n/**\r\n * Extracts text and selection from input block's children.\r\n * @param {Textract.Block}} block - Block that we want to extract contents from.\r\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\r\n */\r\nexport function extractContentsFromBlock(block, blockMap) {\r\n    var words = '';\r\n    var isSelected;\r\n    if (!block.Relationships) {\r\n        // some block might have no content\r\n        return { text: '', selected: undefined };\r\n    }\r\n    block.Relationships.forEach(function (relation) {\r\n        relation.Ids.forEach(function (contentId) {\r\n            var contentBlock = blockMap[contentId];\r\n            if (contentBlock.BlockType === 'WORD') {\r\n                words += contentBlock.Text + ' ';\r\n            }\r\n            else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\r\n                isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\r\n            }\r\n        });\r\n    });\r\n    words = words.substr(0, words.length - 1); // remove trailing space.\r\n    return { text: words, selected: isSelected };\r\n}\r\n//# sourceMappingURL=IdentifyTextUtils.js.map"]},"metadata":{},"sourceType":"module"}