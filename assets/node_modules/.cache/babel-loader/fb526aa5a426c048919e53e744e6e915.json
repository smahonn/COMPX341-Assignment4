{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SHORT_TO_HEX = {};\nvar HEX_TO_SHORT = {};\n\nfor (var i = 0; i < 256; i++) {\n  var encodedByte = i.toString(16).toLowerCase();\n\n  if (encodedByte.length === 1) {\n    encodedByte = \"0\" + encodedByte;\n  }\n\n  SHORT_TO_HEX[i] = encodedByte;\n  HEX_TO_SHORT[encodedByte] = i;\n}\n/**\r\n * Converts a hexadecimal encoded string to a Uint8Array of bytes.\r\n *\r\n * @param encoded The hexadecimal encoded string\r\n */\n\n\nfunction fromHex(encoded) {\n  if (encoded.length % 2 !== 0) {\n    throw new Error(\"Hex encoded strings must have an even number length\");\n  }\n\n  var out = new Uint8Array(encoded.length / 2);\n\n  for (var i = 0; i < encoded.length; i += 2) {\n    var encodedByte = encoded.substr(i, 2).toLowerCase();\n\n    if (encodedByte in HEX_TO_SHORT) {\n      out[i / 2] = HEX_TO_SHORT[encodedByte];\n    } else {\n      throw new Error(\"Cannot decode unrecognized sequence \" + encodedByte + \" as hexadecimal\");\n    }\n  }\n\n  return out;\n}\n\nexports.fromHex = fromHex;\n/**\r\n * Converts a Uint8Array of binary data to a hexadecimal encoded string.\r\n *\r\n * @param bytes The binary data to encode\r\n */\n\nfunction toHex(bytes) {\n  var out = \"\";\n\n  for (var i = 0; i < bytes.byteLength; i++) {\n    out += SHORT_TO_HEX[bytes[i]];\n  }\n\n  return out;\n}\n\nexports.toHex = toHex;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;AAAA,IAAM,YAAY,GAA8B,EAAhD;AACA,IAAM,YAAY,GAA8B,EAAhD;;AAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,MAAI,WAAW,GAAG,CAAC,CAAC,QAAF,CAAW,EAAX,EAAe,WAAf,EAAlB;;AACA,MAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,IAAA,WAAW,GAAG,MAAI,WAAlB;AACD;;AAED,EAAA,YAAY,CAAC,CAAD,CAAZ,GAAkB,WAAlB;AACA,EAAA,YAAY,CAAC,WAAD,CAAZ,GAA4B,CAA5B;AACD;AAED;;;;AAIG;;;AACH,SAAgB,OAAhB,CAAwB,OAAxB,EAAuC;AACrC,MAAI,OAAO,CAAC,MAAR,GAAiB,CAAjB,KAAuB,CAA3B,EAA8B;AAC5B,UAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAED,MAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,OAAO,CAAC,MAAR,GAAiB,CAAhC,CAAZ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,IAAI,CAAzC,EAA4C;AAC1C,QAAM,WAAW,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,EAAkB,CAAlB,EAAqB,WAArB,EAApB;;AACA,QAAI,WAAW,IAAI,YAAnB,EAAiC;AAC/B,MAAA,GAAG,CAAC,CAAC,GAAG,CAAL,CAAH,GAAa,YAAY,CAAC,WAAD,CAAzB;AACD,KAFD,MAEO;AACL,YAAM,IAAI,KAAJ,CACJ,yCAAuC,WAAvC,GAAkD,iBAD9C,CAAN;AAGD;AACF;;AAED,SAAO,GAAP;AACD;;AAlBD,OAAA,CAAA,OAAA,GAAA,OAAA;AAoBA;;;;AAIG;;AACH,SAAgB,KAAhB,CAAsB,KAAtB,EAAuC;AACrC,MAAI,GAAG,GAAG,EAAV;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,UAA1B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,IAAA,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,CAAD,CAAN,CAAnB;AACD;;AAED,SAAO,GAAP;AACD;;AAPD,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"./src/","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SHORT_TO_HEX = {};\r\nvar HEX_TO_SHORT = {};\r\nfor (var i = 0; i < 256; i++) {\r\n    var encodedByte = i.toString(16).toLowerCase();\r\n    if (encodedByte.length === 1) {\r\n        encodedByte = \"0\" + encodedByte;\r\n    }\r\n    SHORT_TO_HEX[i] = encodedByte;\r\n    HEX_TO_SHORT[encodedByte] = i;\r\n}\r\n/**\r\n * Converts a hexadecimal encoded string to a Uint8Array of bytes.\r\n *\r\n * @param encoded The hexadecimal encoded string\r\n */\r\nfunction fromHex(encoded) {\r\n    if (encoded.length % 2 !== 0) {\r\n        throw new Error(\"Hex encoded strings must have an even number length\");\r\n    }\r\n    var out = new Uint8Array(encoded.length / 2);\r\n    for (var i = 0; i < encoded.length; i += 2) {\r\n        var encodedByte = encoded.substr(i, 2).toLowerCase();\r\n        if (encodedByte in HEX_TO_SHORT) {\r\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\r\n        }\r\n        else {\r\n            throw new Error(\"Cannot decode unrecognized sequence \" + encodedByte + \" as hexadecimal\");\r\n        }\r\n    }\r\n    return out;\r\n}\r\nexports.fromHex = fromHex;\r\n/**\r\n * Converts a Uint8Array of binary data to a hexadecimal encoded string.\r\n *\r\n * @param bytes The binary data to encode\r\n */\r\nfunction toHex(bytes) {\r\n    var out = \"\";\r\n    for (var i = 0; i < bytes.byteLength; i++) {\r\n        out += SHORT_TO_HEX[bytes[i]];\r\n    }\r\n    return out;\r\n}\r\nexports.toHex = toHex;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}