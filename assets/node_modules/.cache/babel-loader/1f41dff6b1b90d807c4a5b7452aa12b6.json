{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\n\n\nimport { GraphQLError } from '../../error/GraphQLError';\nimport inspect from '../../jsutils/inspect';\nimport find from '../../jsutils/find';\nimport { Kind } from '../../language/kinds';\nimport { print } from '../../language/printer';\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function fieldsConflictMessage(responseName, reason) {\n  return \"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(reason)) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(subreason));\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n */\n\n\nexport function OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i = 0; _i < conflicts.length; _i++) {\n        var _ref3 = conflicts[_i];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n\n  comparedFragments[fragmentName] = true;\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  var _arr = Object.keys(fieldMap);\n\n  for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n    var responseName = _arr[_i3];\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  var _arr2 = Object.keys(fieldMap1);\n\n  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\n    var responseName = _arr2[_i4];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2); // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\".concat(name1, \" and \").concat(name2, \" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \".concat(inspect(type1), \" and \").concat(inspect(type2))], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref4) {\n      var reason = _ref4[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref5) {\n      var fields1 = _ref5[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref6) {\n      var fields2 = _ref6[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does\r\n * not matter. We do this by maintaining a sort of double adjacency sets.\r\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    _defineProperty(this, \"_data\", void 0);\n\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/@aws-amplify/api/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.mjs"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","GraphQLError","inspect","find","Kind","print","getNamedType","isNonNullType","isLeafType","isObjectType","isListType","isInterfaceType","typeFromAST","fieldsConflictMessage","responseName","reason","concat","reasonMessage","Array","isArray","map","_ref","subreason","join","OverlappingFieldsCanBeMerged","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","_i","length","_ref3","_ref2$","fields1","fields2","reportError","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","comparedFragments","create","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_comparedFragments","_i2","_j","_arr","keys","_i3","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","_arr2","_i4","field1","field2","node1","def1","node2","def2","type1","type","type2","name1","name","name2","sameArguments","arguments","doTypesConflict","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","ofType","cached","get","nodeAndDefs","_collectFieldsAndFragmentNames","set","fragmentType","getSchema","typeCondition","selections","selection","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref4","reduce","allFields","_ref5","_ref6","_data","_proto","prototype","a","b","first","result","undefined","_pairSetAdd","data"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;AAAE,MAAID,GAAG,IAAID,GAAX,EAAgB;AAAEG,IAAAA,MAAM,CAACC,cAAP,CAAsBJ,GAAtB,EAA2BC,GAA3B,EAAgC;AAAEC,MAAAA,KAAK,EAAEA,KAAT;AAAgBG,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEP,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AAAmB;;AAAC,SAAOF,GAAP;AAAa;AAEjN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,YAAT,QAA6B,0BAA7B;AACA,OAAOC,OAAP,MAAoB,uBAApB;AACA,OAAOC,IAAP,MAAiB,oBAAjB;AACA,SAASC,IAAT,QAAqB,sBAArB;AACA,SAASC,KAAT,QAAsB,wBAAtB;AACA,SAASC,YAAT,EAAuBC,aAAvB,EAAsCC,UAAtC,EAAkDC,YAAlD,EAAgEC,UAAhE,EAA4EC,eAA5E,QAAmG,uBAAnG;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,OAAO,SAASC,qBAAT,CAA+BC,YAA/B,EAA6CC,MAA7C,EAAqD;AAC1D,SAAO,YAAYC,MAAZ,CAAmBF,YAAnB,EAAiC,sBAAjC,EAAyDE,MAAzD,CAAgEC,aAAa,CAACF,MAAD,CAA7E,IAAyF,kEAAzF,GAA8J,cAArK;AACD;;AAED,SAASE,aAAT,CAAuBF,MAAvB,EAA+B;AAC7B,MAAIG,KAAK,CAACC,OAAN,CAAcJ,MAAd,CAAJ,EAA2B;AACzB,WAAOA,MAAM,CAACK,GAAP,CAAW,UAAUC,IAAV,EAAgB;AAChC,UAAIP,YAAY,GAAGO,IAAI,CAAC,CAAD,CAAvB;AAAA,UACIC,SAAS,GAAGD,IAAI,CAAC,CAAD,CADpB;AAEA,aAAO,eAAeL,MAAf,CAAsBF,YAAtB,EAAoC,sBAApC,EAA4DE,MAA5D,CAAmEC,aAAa,CAACK,SAAD,CAAhF,CAAP;AACD,KAJM,EAIJC,IAJI,CAIC,OAJD,CAAP;AAKD;;AAED,SAAOR,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAASS,4BAAT,CAAsCC,OAAtC,EAA+C;AACpD;AACA;AACA;AACA,MAAIC,qBAAqB,GAAG,IAAIC,OAAJ,EAA5B,CAJoD,CAIT;AAC3C;AACA;;AAEA,MAAIC,4BAA4B,GAAG,IAAIC,GAAJ,EAAnC;AACA,SAAO;AACLC,IAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,YAAtB,EAAoC;AAChD,UAAIC,SAAS,GAAGC,+BAA+B,CAACR,OAAD,EAAUG,4BAAV,EAAwCF,qBAAxC,EAA+DD,OAAO,CAACS,aAAR,EAA/D,EAAwFH,YAAxF,CAA/C;;AAEA,WAAK,IAAII,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,SAAS,CAACI,MAAhC,EAAwCD,EAAE,EAA1C,EAA8C;AAC5C,YAAIE,KAAK,GAAGL,SAAS,CAACG,EAAD,CAArB;AACA,YAAIG,MAAM,GAAGD,KAAK,CAAC,CAAD,CAAlB;AACA,YAAIvB,YAAY,GAAGwB,MAAM,CAAC,CAAD,CAAzB;AACA,YAAIvB,MAAM,GAAGuB,MAAM,CAAC,CAAD,CAAnB;AACA,YAAIC,OAAO,GAAGF,KAAK,CAAC,CAAD,CAAnB;AACA,YAAIG,OAAO,GAAGH,KAAK,CAAC,CAAD,CAAnB;AACAZ,QAAAA,OAAO,CAACgB,WAAR,CAAoB,IAAIxC,YAAJ,CAAiBY,qBAAqB,CAACC,YAAD,EAAeC,MAAf,CAAtC,EAA8DwB,OAAO,CAACvB,MAAR,CAAewB,OAAf,CAA9D,CAApB;AACD;AACF;AAbI,GAAP;AAeD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASP,+BAAT,CAAyCR,OAAzC,EAAkDG,4BAAlD,EAAgFF,qBAAhF,EAAuGgB,UAAvG,EAAmHX,YAAnH,EAAiI;AAC/H,MAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAIW,qBAAqB,GAAGC,yBAAyB,CAACnB,OAAD,EAAUG,4BAAV,EAAwCc,UAAxC,EAAoDX,YAApD,CAArD;AAAA,MACIc,QAAQ,GAAGF,qBAAqB,CAAC,CAAD,CADpC;AAAA,MAEIG,aAAa,GAAGH,qBAAqB,CAAC,CAAD,CAFzC,CAH+H,CAKjF;AAC9C;;;AAGAI,EAAAA,sBAAsB,CAACtB,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0EmB,QAA1E,CAAtB;;AAEA,MAAIC,aAAa,CAACV,MAAd,KAAyB,CAA7B,EAAgC;AAC9B;AACA;AACA,QAAIY,iBAAiB,GAAGpD,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAxB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,aAAa,CAACV,MAAlC,EAA0Cc,CAAC,EAA3C,EAA+C;AAC7CC,MAAAA,wCAAwC,CAAC1B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDoB,iBAAnD,EAAsEtB,qBAAtE,EAA6F,KAA7F,EAAoGmB,QAApG,EAA8GC,aAAa,CAACI,CAAD,CAA3H,CAAxC,CAD6C,CAC4H;AACzK;AACA;AACA;;AAEA,WAAK,IAAIE,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAGN,aAAa,CAACV,MAAtC,EAA8CgB,CAAC,EAA/C,EAAmD;AACjDC,QAAAA,gCAAgC,CAAC5B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E,KAA1E,EAAiFoB,aAAa,CAACI,CAAD,CAA9F,EAAmGJ,aAAa,CAACM,CAAD,CAAhH,CAAhC;AACD;AACF;AACF;;AAED,SAAOpB,SAAP;AACD,C,CAAC;AACF;;;AAGA,SAASmB,wCAAT,CAAkD1B,OAAlD,EAA2DO,SAA3D,EAAsEJ,4BAAtE,EAAoGoB,iBAApG,EAAuHtB,qBAAvH,EAA8I4B,oBAA9I,EAAoKT,QAApK,EAA8KU,YAA9K,EAA4L;AAC1L;AACA,MAAIP,iBAAiB,CAACO,YAAD,CAArB,EAAqC;AACnC;AACD;;AAEDP,EAAAA,iBAAiB,CAACO,YAAD,CAAjB,GAAkC,IAAlC;AACA,MAAIC,QAAQ,GAAG/B,OAAO,CAACgC,WAAR,CAAoBF,YAApB,CAAf;;AAEA,MAAI,CAACC,QAAL,EAAe;AACb;AACD;;AAED,MAAIE,qBAAqB,GAAGC,mCAAmC,CAAClC,OAAD,EAAUG,4BAAV,EAAwC4B,QAAxC,CAA/D;AAAA,MACII,SAAS,GAAGF,qBAAqB,CAAC,CAAD,CADrC;AAAA,MAEIG,cAAc,GAAGH,qBAAqB,CAAC,CAAD,CAF1C,CAb0L,CAe3I;;;AAG/C,MAAIb,QAAQ,KAAKe,SAAjB,EAA4B;AAC1B;AACD,GApByL,CAoBxL;AACF;;;AAGAE,EAAAA,uBAAuB,CAACrC,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGT,QAAhG,EAA0Ge,SAA1G,CAAvB,CAxB0L,CAwB7C;AAC7I;;AAEA,OAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,cAAc,CAACzB,MAAnC,EAA2Cc,CAAC,EAA5C,EAAgD;AAC9CC,IAAAA,wCAAwC,CAAC1B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDoB,iBAAnD,EAAsEtB,qBAAtE,EAA6F4B,oBAA7F,EAAmHT,QAAnH,EAA6HgB,cAAc,CAACX,CAAD,CAA3I,CAAxC;AACD;AACF,C,CAAC;AACF;;;AAGA,SAASG,gCAAT,CAA0C5B,OAA1C,EAAmDO,SAAnD,EAA8DJ,4BAA9D,EAA4FF,qBAA5F,EAAmH4B,oBAAnH,EAAyIS,aAAzI,EAAwJC,aAAxJ,EAAuK;AACrK;AACA,MAAID,aAAa,KAAKC,aAAtB,EAAqC;AACnC;AACD,GAJoK,CAInK;;;AAGF,MAAItC,qBAAqB,CAACuC,GAAtB,CAA0BF,aAA1B,EAAyCC,aAAzC,EAAwDV,oBAAxD,CAAJ,EAAmF;AACjF;AACD;;AAED5B,EAAAA,qBAAqB,CAACwC,GAAtB,CAA0BH,aAA1B,EAAyCC,aAAzC,EAAwDV,oBAAxD;AACA,MAAIa,SAAS,GAAG1C,OAAO,CAACgC,WAAR,CAAoBM,aAApB,CAAhB;AACA,MAAIK,SAAS,GAAG3C,OAAO,CAACgC,WAAR,CAAoBO,aAApB,CAAhB;;AAEA,MAAI,CAACG,SAAD,IAAc,CAACC,SAAnB,EAA8B;AAC5B;AACD;;AAED,MAAIC,sBAAsB,GAAGV,mCAAmC,CAAClC,OAAD,EAAUG,4BAAV,EAAwCuC,SAAxC,CAAhE;AAAA,MACIG,SAAS,GAAGD,sBAAsB,CAAC,CAAD,CADtC;AAAA,MAEIE,cAAc,GAAGF,sBAAsB,CAAC,CAAD,CAF3C;;AAIA,MAAIG,sBAAsB,GAAGb,mCAAmC,CAAClC,OAAD,EAAUG,4BAAV,EAAwCwC,SAAxC,CAAhE;AAAA,MACIR,SAAS,GAAGY,sBAAsB,CAAC,CAAD,CADtC;AAAA,MAEIX,cAAc,GAAGW,sBAAsB,CAAC,CAAD,CAF3C,CAvBqK,CAyBrH;AAChD;;;AAGAV,EAAAA,uBAAuB,CAACrC,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGgB,SAAhG,EAA2GV,SAA3G,CAAvB,CA7BqK,CA6BvB;AAC9I;;AAEA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,cAAc,CAACzB,MAAnC,EAA2CgB,CAAC,EAA5C,EAAgD;AAC9CC,IAAAA,gCAAgC,CAAC5B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGS,aAAhG,EAA+GF,cAAc,CAACT,CAAD,CAA7H,CAAhC;AACD,GAlCoK,CAkCnK;AACF;;;AAGA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,cAAc,CAACnC,MAAnC,EAA2Cc,CAAC,EAA5C,EAAgD;AAC9CG,IAAAA,gCAAgC,CAAC5B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGiB,cAAc,CAACrB,CAAD,CAA9G,EAAmHc,aAAnH,CAAhC;AACD;AACF,C,CAAC;AACF;AACA;;;AAGA,SAASS,oCAAT,CAA8ChD,OAA9C,EAAuDG,4BAAvD,EAAqFF,qBAArF,EAA4G4B,oBAA5G,EAAkIoB,WAAlI,EAA+IC,aAA/I,EAA8JC,WAA9J,EAA2KC,aAA3K,EAA0L;AACxL,MAAI7C,SAAS,GAAG,EAAhB;;AAEA,MAAI8C,sBAAsB,GAAGlC,yBAAyB,CAACnB,OAAD,EAAUG,4BAAV,EAAwC8C,WAAxC,EAAqDC,aAArD,CAAtD;AAAA,MACIL,SAAS,GAAGQ,sBAAsB,CAAC,CAAD,CADtC;AAAA,MAEIP,cAAc,GAAGO,sBAAsB,CAAC,CAAD,CAF3C;;AAIA,MAAIC,sBAAsB,GAAGnC,yBAAyB,CAACnB,OAAD,EAAUG,4BAAV,EAAwCgD,WAAxC,EAAqDC,aAArD,CAAtD;AAAA,MACIjB,SAAS,GAAGmB,sBAAsB,CAAC,CAAD,CADtC;AAAA,MAEIlB,cAAc,GAAGkB,sBAAsB,CAAC,CAAD,CAF3C,CAPwL,CASxI;;;AAGhDjB,EAAAA,uBAAuB,CAACrC,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGgB,SAAhG,EAA2GV,SAA3G,CAAvB,CAZwL,CAY1C;AAC9I;;AAEA,MAAIC,cAAc,CAACzB,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,QAAIY,iBAAiB,GAAGpD,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAxB;;AAEA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,cAAc,CAACzB,MAAnC,EAA2CgB,CAAC,EAA5C,EAAgD;AAC9CD,MAAAA,wCAAwC,CAAC1B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDoB,iBAAnD,EAAsEtB,qBAAtE,EAA6F4B,oBAA7F,EAAmHgB,SAAnH,EAA8HT,cAAc,CAACT,CAAD,CAA5I,CAAxC;AACD;AACF,GArBuL,CAqBtL;AACF;;;AAGA,MAAImB,cAAc,CAACnC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,QAAI4C,kBAAkB,GAAGpF,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAzB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,cAAc,CAACnC,MAAnC,EAA2Cc,CAAC,EAA5C,EAAgD;AAC9CC,MAAAA,wCAAwC,CAAC1B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDoD,kBAAnD,EAAuEtD,qBAAvE,EAA8F4B,oBAA9F,EAAoHM,SAApH,EAA+HW,cAAc,CAACrB,CAAD,CAA7I,CAAxC;AACD;AACF,GA/BuL,CA+BtL;AACF;AACA;;;AAGA,OAAK,IAAI+B,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,cAAc,CAACnC,MAAvC,EAA+C6C,GAAG,EAAlD,EAAsD;AACpD,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGrB,cAAc,CAACzB,MAArC,EAA6C8C,EAAE,EAA/C,EAAmD;AACjD7B,MAAAA,gCAAgC,CAAC5B,OAAD,EAAUO,SAAV,EAAqBJ,4BAArB,EAAmDF,qBAAnD,EAA0E4B,oBAA1E,EAAgGiB,cAAc,CAACU,GAAD,CAA9G,EAAqHpB,cAAc,CAACqB,EAAD,CAAnI,CAAhC;AACD;AACF;;AAED,SAAOlD,SAAP;AACD,C,CAAC;;;AAGF,SAASe,sBAAT,CAAgCtB,OAAhC,EAAyCO,SAAzC,EAAoDJ,4BAApD,EAAkFF,qBAAlF,EAAyGmB,QAAzG,EAAmH;AACjH;AACA;AACA;AACA;AACA,MAAIsC,IAAI,GAAGvF,MAAM,CAACwF,IAAP,CAAYvC,QAAZ,CAAX;;AAEA,OAAK,IAAIwC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,IAAI,CAAC/C,MAA7B,EAAqCiD,GAAG,EAAxC,EAA4C;AAC1C,QAAIvE,YAAY,GAAGqE,IAAI,CAACE,GAAD,CAAvB;AACA,QAAIC,MAAM,GAAGzC,QAAQ,CAAC/B,YAAD,CAArB,CAF0C,CAEL;AACrC;AACA;;AAEA,QAAIwE,MAAM,CAAClD,MAAP,GAAgB,CAApB,EAAuB;AACrB,WAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,MAAM,CAAClD,MAA3B,EAAmCc,CAAC,EAApC,EAAwC;AACtC,aAAK,IAAIE,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAGkC,MAAM,CAAClD,MAA/B,EAAuCgB,CAAC,EAAxC,EAA4C;AAC1C,cAAImC,QAAQ,GAAGC,YAAY,CAAC/D,OAAD,EAAUG,4BAAV,EAAwCF,qBAAxC,EAA+D,KAA/D,EAAsE;AACjGZ,UAAAA,YAD2B,EACbwE,MAAM,CAACpC,CAAD,CADO,EACFoC,MAAM,CAAClC,CAAD,CADJ,CAA3B;;AAGA,cAAImC,QAAJ,EAAc;AACZvD,YAAAA,SAAS,CAACyD,IAAV,CAAeF,QAAf;AACD;AACF;AACF;AACF;AACF;AACF,C,CAAC;AACF;AACA;AACA;AACA;;;AAGA,SAASzB,uBAAT,CAAiCrC,OAAjC,EAA0CO,SAA1C,EAAqDJ,4BAArD,EAAmFF,qBAAnF,EAA0GgE,gCAA1G,EAA4IpB,SAA5I,EAAuJV,SAAvJ,EAAkK;AAChK;AACA;AACA;AACA;AACA;AACA,MAAI+B,KAAK,GAAG/F,MAAM,CAACwF,IAAP,CAAYd,SAAZ,CAAZ;;AAEA,OAAK,IAAIsB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,KAAK,CAACvD,MAA9B,EAAsCwD,GAAG,EAAzC,EAA6C;AAC3C,QAAI9E,YAAY,GAAG6E,KAAK,CAACC,GAAD,CAAxB;AACA,QAAIpD,OAAO,GAAGoB,SAAS,CAAC9C,YAAD,CAAvB;;AAEA,QAAI0B,OAAJ,EAAa;AACX,UAAID,OAAO,GAAG+B,SAAS,CAACxD,YAAD,CAAvB;;AAEA,WAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,OAAO,CAACH,MAA5B,EAAoCc,CAAC,EAArC,EAAyC;AACvC,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,OAAO,CAACJ,MAA5B,EAAoCgB,CAAC,EAArC,EAAyC;AACvC,cAAImC,QAAQ,GAAGC,YAAY,CAAC/D,OAAD,EAAUG,4BAAV,EAAwCF,qBAAxC,EAA+DgE,gCAA/D,EAAiG5E,YAAjG,EAA+GyB,OAAO,CAACW,CAAD,CAAtH,EAA2HV,OAAO,CAACY,CAAD,CAAlI,CAA3B;;AAEA,cAAImC,QAAJ,EAAc;AACZvD,YAAAA,SAAS,CAACyD,IAAV,CAAeF,QAAf;AACD;AACF;AACF;AACF;AACF;AACF,C,CAAC;AACF;;;AAGA,SAASC,YAAT,CAAsB/D,OAAtB,EAA+BG,4BAA/B,EAA6DF,qBAA7D,EAAoFgE,gCAApF,EAAsH5E,YAAtH,EAAoI+E,MAApI,EAA4IC,MAA5I,EAAoJ;AAClJ,MAAIpB,WAAW,GAAGmB,MAAM,CAAC,CAAD,CAAxB;AAAA,MACIE,KAAK,GAAGF,MAAM,CAAC,CAAD,CADlB;AAAA,MAEIG,IAAI,GAAGH,MAAM,CAAC,CAAD,CAFjB;AAGA,MAAIjB,WAAW,GAAGkB,MAAM,CAAC,CAAD,CAAxB;AAAA,MACIG,KAAK,GAAGH,MAAM,CAAC,CAAD,CADlB;AAAA,MAEII,IAAI,GAAGJ,MAAM,CAAC,CAAD,CAFjB,CAJkJ,CAM5H;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAIxC,oBAAoB,GAAGoC,gCAAgC,IAAIhB,WAAW,KAAKE,WAAhB,IAA+BnE,YAAY,CAACiE,WAAD,CAA3C,IAA4DjE,YAAY,CAACmE,WAAD,CAAvI,CAfkJ,CAeI;;AAEtJ,MAAIuB,KAAK,GAAGH,IAAI,IAAIA,IAAI,CAACI,IAAzB;AACA,MAAIC,KAAK,GAAGH,IAAI,IAAIA,IAAI,CAACE,IAAzB;;AAEA,MAAI,CAAC9C,oBAAL,EAA2B;AACzB;AACA,QAAIgD,KAAK,GAAGP,KAAK,CAACQ,IAAN,CAAW5G,KAAvB;AACA,QAAI6G,KAAK,GAAGP,KAAK,CAACM,IAAN,CAAW5G,KAAvB;;AAEA,QAAI2G,KAAK,KAAKE,KAAd,EAAqB;AACnB,aAAO,CAAC,CAAC1F,YAAD,EAAe,GAAGE,MAAH,CAAUsF,KAAV,EAAiB,OAAjB,EAA0BtF,MAA1B,CAAiCwF,KAAjC,EAAwC,uBAAxC,CAAf,CAAD,EAAmF,CAACT,KAAD,CAAnF,EAA4F,CAACE,KAAD,CAA5F,CAAP;AACD,KAPwB,CAOvB;;;AAGF,QAAI,CAACQ,aAAa,CAACV,KAAK,CAACW,SAAN,IAAmB,EAApB,EAAwBT,KAAK,CAACS,SAAN,IAAmB,EAA3C,CAAlB,EAAkE;AAChE,aAAO,CAAC,CAAC5F,YAAD,EAAe,+BAAf,CAAD,EAAkD,CAACiF,KAAD,CAAlD,EAA2D,CAACE,KAAD,CAA3D,CAAP;AACD;AACF;;AAED,MAAIE,KAAK,IAAIE,KAAT,IAAkBM,eAAe,CAACR,KAAD,EAAQE,KAAR,CAArC,EAAqD;AACnD,WAAO,CAAC,CAACvF,YAAD,EAAe,iCAAiCE,MAAjC,CAAwCd,OAAO,CAACiG,KAAD,CAA/C,EAAwD,OAAxD,EAAiEnF,MAAjE,CAAwEd,OAAO,CAACmG,KAAD,CAA/E,CAAf,CAAD,EAA0G,CAACN,KAAD,CAA1G,EAAmH,CAACE,KAAD,CAAnH,CAAP;AACD,GArCiJ,CAqChJ;AACF;AACA;;;AAGA,MAAItB,aAAa,GAAGoB,KAAK,CAAChE,YAA1B;AACA,MAAI8C,aAAa,GAAGoB,KAAK,CAAClE,YAA1B;;AAEA,MAAI4C,aAAa,IAAIE,aAArB,EAAoC;AAClC,QAAI7C,SAAS,GAAGyC,oCAAoC,CAAChD,OAAD,EAAUG,4BAAV,EAAwCF,qBAAxC,EAA+D4B,oBAA/D,EAAqFhD,YAAY,CAAC6F,KAAD,CAAjG,EAA0GxB,aAA1G,EAAyHrE,YAAY,CAAC+F,KAAD,CAArI,EAA8IxB,aAA9I,CAApD;AACA,WAAO+B,iBAAiB,CAAC5E,SAAD,EAAYlB,YAAZ,EAA0BiF,KAA1B,EAAiCE,KAAjC,CAAxB;AACD;AACF;;AAED,SAASQ,aAAT,CAAuBI,UAAvB,EAAmCC,UAAnC,EAA+C;AAC7C,MAAID,UAAU,CAACzE,MAAX,KAAsB0E,UAAU,CAAC1E,MAArC,EAA6C;AAC3C,WAAO,KAAP;AACD;;AAED,SAAOyE,UAAU,CAACE,KAAX,CAAiB,UAAUC,SAAV,EAAqB;AAC3C,QAAIC,SAAS,GAAG9G,IAAI,CAAC2G,UAAD,EAAa,UAAUI,QAAV,EAAoB;AACnD,aAAOA,QAAQ,CAACX,IAAT,CAAc5G,KAAd,KAAwBqH,SAAS,CAACT,IAAV,CAAe5G,KAA9C;AACD,KAFmB,CAApB;;AAIA,QAAI,CAACsH,SAAL,EAAgB;AACd,aAAO,KAAP;AACD;;AAED,WAAOE,SAAS,CAACH,SAAS,CAACrH,KAAX,EAAkBsH,SAAS,CAACtH,KAA5B,CAAhB;AACD,GAVM,CAAP;AAWD;;AAED,SAASwH,SAAT,CAAmBC,MAAnB,EAA2BC,MAA3B,EAAmC;AACjC,SAAO,CAACD,MAAD,IAAW,CAACC,MAAZ,IAAsBhH,KAAK,CAAC+G,MAAD,CAAL,KAAkB/G,KAAK,CAACgH,MAAD,CAApD;AACD,C,CAAC;AACF;AACA;;;AAGA,SAASV,eAAT,CAAyBR,KAAzB,EAAgCE,KAAhC,EAAuC;AACrC,MAAI3F,UAAU,CAACyF,KAAD,CAAd,EAAuB;AACrB,WAAOzF,UAAU,CAAC2F,KAAD,CAAV,GAAoBM,eAAe,CAACR,KAAK,CAACmB,MAAP,EAAejB,KAAK,CAACiB,MAArB,CAAnC,GAAkE,IAAzE;AACD;;AAED,MAAI5G,UAAU,CAAC2F,KAAD,CAAd,EAAuB;AACrB,WAAO,IAAP;AACD;;AAED,MAAI9F,aAAa,CAAC4F,KAAD,CAAjB,EAA0B;AACxB,WAAO5F,aAAa,CAAC8F,KAAD,CAAb,GAAuBM,eAAe,CAACR,KAAK,CAACmB,MAAP,EAAejB,KAAK,CAACiB,MAArB,CAAtC,GAAqE,IAA5E;AACD;;AAED,MAAI/G,aAAa,CAAC8F,KAAD,CAAjB,EAA0B;AACxB,WAAO,IAAP;AACD;;AAED,MAAI7F,UAAU,CAAC2F,KAAD,CAAV,IAAqB3F,UAAU,CAAC6F,KAAD,CAAnC,EAA4C;AAC1C,WAAOF,KAAK,KAAKE,KAAjB;AACD;;AAED,SAAO,KAAP;AACD,C,CAAC;AACF;AACA;;;AAGA,SAASzD,yBAAT,CAAmCnB,OAAnC,EAA4CG,4BAA5C,EAA0Ec,UAA1E,EAAsFX,YAAtF,EAAoG;AAClG,MAAIwF,MAAM,GAAG3F,4BAA4B,CAAC4F,GAA7B,CAAiCzF,YAAjC,CAAb;;AAEA,MAAI,CAACwF,MAAL,EAAa;AACX,QAAIE,WAAW,GAAG7H,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAlB;AACA,QAAIH,aAAa,GAAGlD,MAAM,CAACqD,MAAP,CAAc,IAAd,CAApB;;AAEAyE,IAAAA,8BAA8B,CAACjG,OAAD,EAAUiB,UAAV,EAAsBX,YAAtB,EAAoC0F,WAApC,EAAiD3E,aAAjD,CAA9B;;AAEAyE,IAAAA,MAAM,GAAG,CAACE,WAAD,EAAc7H,MAAM,CAACwF,IAAP,CAAYtC,aAAZ,CAAd,CAAT;AACAlB,IAAAA,4BAA4B,CAAC+F,GAA7B,CAAiC5F,YAAjC,EAA+CwF,MAA/C;AACD;;AAED,SAAOA,MAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS5D,mCAAT,CAA6ClC,OAA7C,EAAsDG,4BAAtD,EAAoF4B,QAApF,EAA8F;AAC5F;AACA,MAAI+D,MAAM,GAAG3F,4BAA4B,CAAC4F,GAA7B,CAAiChE,QAAQ,CAACzB,YAA1C,CAAb;;AAEA,MAAIwF,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAIK,YAAY,GAAGhH,WAAW,CAACa,OAAO,CAACoG,SAAR,EAAD,EAAsBrE,QAAQ,CAACsE,aAA/B,CAA9B;AACA,SAAOlF,yBAAyB,CAACnB,OAAD,EAAUG,4BAAV,EAAwCgG,YAAxC,EAAsDpE,QAAQ,CAACzB,YAA/D,CAAhC;AACD;;AAED,SAAS2F,8BAAT,CAAwCjG,OAAxC,EAAiDiB,UAAjD,EAA6DX,YAA7D,EAA2E0F,WAA3E,EAAwF3E,aAAxF,EAAuG;AACrG,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,YAAY,CAACgG,UAAb,CAAwB3F,MAA5C,EAAoDc,CAAC,EAArD,EAAyD;AACvD,QAAI8E,SAAS,GAAGjG,YAAY,CAACgG,UAAb,CAAwB7E,CAAxB,CAAhB;;AAEA,YAAQ8E,SAAS,CAACC,IAAlB;AACE,WAAK7H,IAAI,CAAC8H,KAAV;AACE,YAAIC,SAAS,GAAGH,SAAS,CAACzB,IAAV,CAAe5G,KAA/B;AACA,YAAIyI,QAAQ,GAAG,KAAK,CAApB;;AAEA,YAAI3H,YAAY,CAACiC,UAAD,CAAZ,IAA4B/B,eAAe,CAAC+B,UAAD,CAA/C,EAA6D;AAC3D0F,UAAAA,QAAQ,GAAG1F,UAAU,CAAC2F,SAAX,GAAuBF,SAAvB,CAAX;AACD;;AAED,YAAIrH,YAAY,GAAGkH,SAAS,CAACM,KAAV,GAAkBN,SAAS,CAACM,KAAV,CAAgB3I,KAAlC,GAA0CwI,SAA7D;;AAEA,YAAI,CAACV,WAAW,CAAC3G,YAAD,CAAhB,EAAgC;AAC9B2G,UAAAA,WAAW,CAAC3G,YAAD,CAAX,GAA4B,EAA5B;AACD;;AAED2G,QAAAA,WAAW,CAAC3G,YAAD,CAAX,CAA0B2E,IAA1B,CAA+B,CAAC/C,UAAD,EAAasF,SAAb,EAAwBI,QAAxB,CAA/B;AACA;;AAEF,WAAKhI,IAAI,CAACmI,eAAV;AACEzF,QAAAA,aAAa,CAACkF,SAAS,CAACzB,IAAV,CAAe5G,KAAhB,CAAb,GAAsC,IAAtC;AACA;;AAEF,WAAKS,IAAI,CAACoI,eAAV;AACE,YAAIV,aAAa,GAAGE,SAAS,CAACF,aAA9B;AACA,YAAIW,kBAAkB,GAAGX,aAAa,GAAGlH,WAAW,CAACa,OAAO,CAACoG,SAAR,EAAD,EAAsBC,aAAtB,CAAd,GAAqDpF,UAA3F;;AAEAgF,QAAAA,8BAA8B,CAACjG,OAAD,EAAUgH,kBAAV,EAA8BT,SAAS,CAACjG,YAAxC,EAAsD0F,WAAtD,EAAmE3E,aAAnE,CAA9B;;AAEA;AA5BJ;AA8BD;AACF,C,CAAC;AACF;;;AAGA,SAAS8D,iBAAT,CAA2B5E,SAA3B,EAAsClB,YAAtC,EAAoDiF,KAApD,EAA2DE,KAA3D,EAAkE;AAChE,MAAIjE,SAAS,CAACI,MAAV,GAAmB,CAAvB,EAA0B;AACxB,WAAO,CAAC,CAACtB,YAAD,EAAekB,SAAS,CAACZ,GAAV,CAAc,UAAUsH,KAAV,EAAiB;AACpD,UAAI3H,MAAM,GAAG2H,KAAK,CAAC,CAAD,CAAlB;AACA,aAAO3H,MAAP;AACD,KAHsB,CAAf,CAAD,EAGFiB,SAAS,CAAC2G,MAAV,CAAiB,UAAUC,SAAV,EAAqBC,KAArB,EAA4B;AAChD,UAAItG,OAAO,GAAGsG,KAAK,CAAC,CAAD,CAAnB;AACA,aAAOD,SAAS,CAAC5H,MAAV,CAAiBuB,OAAjB,CAAP;AACD,KAHI,EAGF,CAACwD,KAAD,CAHE,CAHE,EAMM/D,SAAS,CAAC2G,MAAV,CAAiB,UAAUC,SAAV,EAAqBE,KAArB,EAA4B;AACxD,UAAItG,OAAO,GAAGsG,KAAK,CAAC,CAAD,CAAnB;AACA,aAAOF,SAAS,CAAC5H,MAAV,CAAiBwB,OAAjB,CAAP;AACD,KAHY,EAGV,CAACyD,KAAD,CAHU,CANN,CAAP;AAUD;AACF;AACD;AACA;AACA;AACA;;;AAGA,IAAItE,OAAO,GACX,aACA,YAAY;AACV,WAASA,OAAT,GAAmB;AACjBnC,IAAAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAArB,CAAf;;AAEA,SAAKuJ,KAAL,GAAanJ,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAb;AACD;;AAED,MAAI+F,MAAM,GAAGrH,OAAO,CAACsH,SAArB;;AAEAD,EAAAA,MAAM,CAAC/E,GAAP,GAAa,SAASA,GAAT,CAAaiF,CAAb,EAAgBC,CAAhB,EAAmB7F,oBAAnB,EAAyC;AACpD,QAAI8F,KAAK,GAAG,KAAKL,KAAL,CAAWG,CAAX,CAAZ;AACA,QAAIG,MAAM,GAAGD,KAAK,IAAIA,KAAK,CAACD,CAAD,CAA3B;;AAEA,QAAIE,MAAM,KAAKC,SAAf,EAA0B;AACxB,aAAO,KAAP;AACD,KANmD,CAMlD;AACF;AACA;;;AAGA,QAAIhG,oBAAoB,KAAK,KAA7B,EAAoC;AAClC,aAAO+F,MAAM,KAAK,KAAlB;AACD;;AAED,WAAO,IAAP;AACD,GAhBD;;AAkBAL,EAAAA,MAAM,CAAC9E,GAAP,GAAa,SAASA,GAAT,CAAagF,CAAb,EAAgBC,CAAhB,EAAmB7F,oBAAnB,EAAyC;AACpDiG,IAAAA,WAAW,CAAC,KAAKR,KAAN,EAAaG,CAAb,EAAgBC,CAAhB,EAAmB7F,oBAAnB,CAAX;;AAEAiG,IAAAA,WAAW,CAAC,KAAKR,KAAN,EAAaI,CAAb,EAAgBD,CAAhB,EAAmB5F,oBAAnB,CAAX;AACD,GAJD;;AAMA,SAAO3B,OAAP;AACD,CAlCD,EAFA;;AAsCA,SAAS4H,WAAT,CAAqBC,IAArB,EAA2BN,CAA3B,EAA8BC,CAA9B,EAAiC7F,oBAAjC,EAAuD;AACrD,MAAIlC,GAAG,GAAGoI,IAAI,CAACN,CAAD,CAAd;;AAEA,MAAI,CAAC9H,GAAL,EAAU;AACRA,IAAAA,GAAG,GAAGxB,MAAM,CAACqD,MAAP,CAAc,IAAd,CAAN;AACAuG,IAAAA,IAAI,CAACN,CAAD,CAAJ,GAAU9H,GAAV;AACD;;AAEDA,EAAAA,GAAG,CAAC+H,CAAD,CAAH,GAAS7F,oBAAT;AACD","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\n/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\r\nimport { GraphQLError } from '../../error/GraphQLError';\r\nimport inspect from '../../jsutils/inspect';\r\nimport find from '../../jsutils/find';\r\nimport { Kind } from '../../language/kinds';\r\nimport { print } from '../../language/printer';\r\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\r\nimport { typeFromAST } from '../../utilities/typeFromAST';\r\nexport function fieldsConflictMessage(responseName, reason) {\r\n  return \"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(reason)) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\r\n}\r\n\r\nfunction reasonMessage(reason) {\r\n  if (Array.isArray(reason)) {\r\n    return reason.map(function (_ref) {\r\n      var responseName = _ref[0],\r\n          subreason = _ref[1];\r\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(subreason));\r\n    }).join(' and ');\r\n  }\r\n\r\n  return reason;\r\n}\r\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n */\r\n\r\n\r\nexport function OverlappingFieldsCanBeMerged(context) {\r\n  // A memoization for when two fragments are compared \"between\" each other for\r\n  // conflicts. Two fragments may be compared many times, so memoizing this can\r\n  // dramatically improve the performance of this validator.\r\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\r\n  // selection set. Selection sets may be asked for this information multiple\r\n  // times, so this improves the performance of this validator.\r\n\r\n  var cachedFieldsAndFragmentNames = new Map();\r\n  return {\r\n    SelectionSet: function SelectionSet(selectionSet) {\r\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\r\n\r\n      for (var _i = 0; _i < conflicts.length; _i++) {\r\n        var _ref3 = conflicts[_i];\r\n        var _ref2$ = _ref3[0];\r\n        var responseName = _ref2$[0];\r\n        var reason = _ref2$[1];\r\n        var fields1 = _ref3[1];\r\n        var fields2 = _ref3[2];\r\n        context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\r\n// Find all conflicts found \"within\" a selection set, including those found\r\n// via spreading in fragments. Called when visiting each SelectionSet in the\r\n// GraphQL Document.\r\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\r\n  var conflicts = [];\r\n\r\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\r\n      fieldMap = _getFieldsAndFragment[0],\r\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\r\n  // Note: this is the *only place* `collectConflictsWithin` is called.\r\n\r\n\r\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\r\n\r\n  if (fragmentNames.length !== 0) {\r\n    // (B) Then collect conflicts between these fields and those represented by\r\n    // each spread fragment name found.\r\n    var comparedFragments = Object.create(null);\r\n\r\n    for (var i = 0; i < fragmentNames.length; i++) {\r\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\r\n      // selection set to collect conflicts between fragments spread together.\r\n      // This compares each item in the list of fragment names to every other\r\n      // item in that same list (except for itself).\r\n\r\n      for (var j = i + 1; j < fragmentNames.length; j++) {\r\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all conflicts found between a set of fields and a fragment reference\r\n// including via spreading in any nested fragments.\r\n\r\n\r\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\r\n  // Memoize so a fragment is not compared for conflicts more than once.\r\n  if (comparedFragments[fragmentName]) {\r\n    return;\r\n  }\r\n\r\n  comparedFragments[fragmentName] = true;\r\n  var fragment = context.getFragment(fragmentName);\r\n\r\n  if (!fragment) {\r\n    return;\r\n  }\r\n\r\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\r\n      fieldMap2 = _getReferencedFieldsA[0],\r\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\r\n\r\n\r\n  if (fieldMap === fieldMap2) {\r\n    return;\r\n  } // (D) First collect any conflicts between the provided collection of fields\r\n  // and the collection of fields represented by the given fragment.\r\n\r\n\r\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\r\n  // and any fragment names found in the given fragment.\r\n\r\n  for (var i = 0; i < fragmentNames2.length; i++) {\r\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\r\n  }\r\n} // Collect all conflicts found between two fragments, including via spreading in\r\n// any nested fragments.\r\n\r\n\r\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\r\n  // No need to compare a fragment to itself.\r\n  if (fragmentName1 === fragmentName2) {\r\n    return;\r\n  } // Memoize so two fragments are not compared for conflicts more than once.\r\n\r\n\r\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\r\n    return;\r\n  }\r\n\r\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\r\n  var fragment1 = context.getFragment(fragmentName1);\r\n  var fragment2 = context.getFragment(fragmentName2);\r\n\r\n  if (!fragment1 || !fragment2) {\r\n    return;\r\n  }\r\n\r\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\r\n      fieldMap1 = _getReferencedFieldsA2[0],\r\n      fragmentNames1 = _getReferencedFieldsA2[1];\r\n\r\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\r\n      fieldMap2 = _getReferencedFieldsA3[0],\r\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\r\n  // (not including any nested fragments).\r\n\r\n\r\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\r\n  // fragments spread in the second fragment.\r\n\r\n  for (var j = 0; j < fragmentNames2.length; j++) {\r\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\r\n  } // (G) Then collect conflicts between the second fragment and any nested\r\n  // fragments spread in the first fragment.\r\n\r\n\r\n  for (var i = 0; i < fragmentNames1.length; i++) {\r\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\r\n  }\r\n} // Find all conflicts found between two selection sets, including those found\r\n// via spreading in fragments. Called when determining if conflicts exist\r\n// between the sub-fields of two overlapping fields.\r\n\r\n\r\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\r\n  var conflicts = [];\r\n\r\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\r\n      fieldMap1 = _getFieldsAndFragment2[0],\r\n      fragmentNames1 = _getFieldsAndFragment2[1];\r\n\r\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\r\n      fieldMap2 = _getFieldsAndFragment3[0],\r\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\r\n\r\n\r\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\r\n  // those referenced by each fragment name associated with the second.\r\n\r\n  if (fragmentNames2.length !== 0) {\r\n    var comparedFragments = Object.create(null);\r\n\r\n    for (var j = 0; j < fragmentNames2.length; j++) {\r\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\r\n    }\r\n  } // (I) Then collect conflicts between the second collection of fields and\r\n  // those referenced by each fragment name associated with the first.\r\n\r\n\r\n  if (fragmentNames1.length !== 0) {\r\n    var _comparedFragments = Object.create(null);\r\n\r\n    for (var i = 0; i < fragmentNames1.length; i++) {\r\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\r\n    }\r\n  } // (J) Also collect conflicts between any fragment names by the first and\r\n  // fragment names by the second. This compares each item in the first set of\r\n  // names to each item in the second set of names.\r\n\r\n\r\n  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {\r\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\r\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all Conflicts \"within\" one collection of fields.\r\n\r\n\r\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For every response name, if there are multiple fields, they\r\n  // must be compared to find a potential conflict.\r\n  var _arr = Object.keys(fieldMap);\r\n\r\n  for (var _i3 = 0; _i3 < _arr.length; _i3++) {\r\n    var responseName = _arr[_i3];\r\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\r\n    // (except to itself). If the list only has one item, nothing needs to\r\n    // be compared.\r\n\r\n    if (fields.length > 1) {\r\n      for (var i = 0; i < fields.length; i++) {\r\n        for (var j = i + 1; j < fields.length; j++) {\r\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\r\n          responseName, fields[i], fields[j]);\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Collect all Conflicts between two collections of fields. This is similar to,\r\n// but different from the `collectConflictsWithin` function above. This check\r\n// assumes that `collectConflictsWithin` has already been called on each\r\n// provided collection of fields. This is true because this validator traverses\r\n// each individual selection set.\r\n\r\n\r\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For any response name which appears in both provided field\r\n  // maps, each field from the first field map must be compared to every field\r\n  // in the second field map to find potential conflicts.\r\n  var _arr2 = Object.keys(fieldMap1);\r\n\r\n  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\r\n    var responseName = _arr2[_i4];\r\n    var fields2 = fieldMap2[responseName];\r\n\r\n    if (fields2) {\r\n      var fields1 = fieldMap1[responseName];\r\n\r\n      for (var i = 0; i < fields1.length; i++) {\r\n        for (var j = 0; j < fields2.length; j++) {\r\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Determines if there is a conflict between two particular fields, including\r\n// comparing their sub-fields.\r\n\r\n\r\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\r\n  var parentType1 = field1[0],\r\n      node1 = field1[1],\r\n      def1 = field1[2];\r\n  var parentType2 = field2[0],\r\n      node2 = field2[1],\r\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\r\n  // time, due to the parent types, then it is safe to permit them to diverge\r\n  // in aliased field or arguments used as they will not present any ambiguity\r\n  // by differing.\r\n  // It is known that two parent types could never overlap if they are\r\n  // different Object types. Interface or Union types might overlap - if not\r\n  // in the current state of the schema, then perhaps in some future version,\r\n  // thus may not safely diverge.\r\n\r\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2); // The return type for each field.\r\n\r\n  var type1 = def1 && def1.type;\r\n  var type2 = def2 && def2.type;\r\n\r\n  if (!areMutuallyExclusive) {\r\n    // Two aliases must refer to the same field.\r\n    var name1 = node1.name.value;\r\n    var name2 = node2.name.value;\r\n\r\n    if (name1 !== name2) {\r\n      return [[responseName, \"\".concat(name1, \" and \").concat(name2, \" are different fields\")], [node1], [node2]];\r\n    } // Two field calls must have the same arguments.\r\n\r\n\r\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\r\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\r\n    }\r\n  }\r\n\r\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\r\n    return [[responseName, \"they return conflicting types \".concat(inspect(type1), \" and \").concat(inspect(type2))], [node1], [node2]];\r\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\r\n  // for both collections so fields in a fragment reference are never\r\n  // compared to themselves.\r\n\r\n\r\n  var selectionSet1 = node1.selectionSet;\r\n  var selectionSet2 = node2.selectionSet;\r\n\r\n  if (selectionSet1 && selectionSet2) {\r\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\r\n    return subfieldConflicts(conflicts, responseName, node1, node2);\r\n  }\r\n}\r\n\r\nfunction sameArguments(arguments1, arguments2) {\r\n  if (arguments1.length !== arguments2.length) {\r\n    return false;\r\n  }\r\n\r\n  return arguments1.every(function (argument1) {\r\n    var argument2 = find(arguments2, function (argument) {\r\n      return argument.name.value === argument1.name.value;\r\n    });\r\n\r\n    if (!argument2) {\r\n      return false;\r\n    }\r\n\r\n    return sameValue(argument1.value, argument2.value);\r\n  });\r\n}\r\n\r\nfunction sameValue(value1, value2) {\r\n  return !value1 && !value2 || print(value1) === print(value2);\r\n} // Two types conflict if both types could not apply to a value simultaneously.\r\n// Composite types are ignored as their individual field types will be compared\r\n// later recursively. However List and Non-Null types must match.\r\n\r\n\r\nfunction doTypesConflict(type1, type2) {\r\n  if (isListType(type1)) {\r\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\r\n  }\r\n\r\n  if (isListType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isNonNullType(type1)) {\r\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\r\n  }\r\n\r\n  if (isNonNullType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isLeafType(type1) || isLeafType(type2)) {\r\n    return type1 !== type2;\r\n  }\r\n\r\n  return false;\r\n} // Given a selection set, return the collection of fields (a mapping of response\r\n// name to field nodes and definitions) as well as a list of fragment names\r\n// referenced via fragment spreads.\r\n\r\n\r\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\r\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\r\n\r\n  if (!cached) {\r\n    var nodeAndDefs = Object.create(null);\r\n    var fragmentNames = Object.create(null);\r\n\r\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\r\n\r\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\r\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\r\n  }\r\n\r\n  return cached;\r\n} // Given a reference to a fragment, return the represented collection of fields\r\n// as well as a list of nested fragment names referenced via fragment spreads.\r\n\r\n\r\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\r\n  // Short-circuit building a type from the node if possible.\r\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\r\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\r\n}\r\n\r\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\r\n  for (var i = 0; i < selectionSet.selections.length; i++) {\r\n    var selection = selectionSet.selections[i];\r\n\r\n    switch (selection.kind) {\r\n      case Kind.FIELD:\r\n        var fieldName = selection.name.value;\r\n        var fieldDef = void 0;\r\n\r\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n          fieldDef = parentType.getFields()[fieldName];\r\n        }\r\n\r\n        var responseName = selection.alias ? selection.alias.value : fieldName;\r\n\r\n        if (!nodeAndDefs[responseName]) {\r\n          nodeAndDefs[responseName] = [];\r\n        }\r\n\r\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\r\n        break;\r\n\r\n      case Kind.FRAGMENT_SPREAD:\r\n        fragmentNames[selection.name.value] = true;\r\n        break;\r\n\r\n      case Kind.INLINE_FRAGMENT:\r\n        var typeCondition = selection.typeCondition;\r\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\r\n\r\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\r\n\r\n        break;\r\n    }\r\n  }\r\n} // Given a series of Conflicts which occurred between two sub-fields, generate\r\n// a single Conflict.\r\n\r\n\r\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\r\n  if (conflicts.length > 0) {\r\n    return [[responseName, conflicts.map(function (_ref4) {\r\n      var reason = _ref4[0];\r\n      return reason;\r\n    })], conflicts.reduce(function (allFields, _ref5) {\r\n      var fields1 = _ref5[1];\r\n      return allFields.concat(fields1);\r\n    }, [node1]), conflicts.reduce(function (allFields, _ref6) {\r\n      var fields2 = _ref6[2];\r\n      return allFields.concat(fields2);\r\n    }, [node2])];\r\n  }\r\n}\r\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does\r\n * not matter. We do this by maintaining a sort of double adjacency sets.\r\n */\r\n\r\n\r\nvar PairSet =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function PairSet() {\r\n    _defineProperty(this, \"_data\", void 0);\r\n\r\n    this._data = Object.create(null);\r\n  }\r\n\r\n  var _proto = PairSet.prototype;\r\n\r\n  _proto.has = function has(a, b, areMutuallyExclusive) {\r\n    var first = this._data[a];\r\n    var result = first && first[b];\r\n\r\n    if (result === undefined) {\r\n      return false;\r\n    } // areMutuallyExclusive being false is a superset of being true,\r\n    // hence if we want to know if this PairSet \"has\" these two with no\r\n    // exclusivity, we have to ensure it was added as such.\r\n\r\n\r\n    if (areMutuallyExclusive === false) {\r\n      return result === false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  _proto.add = function add(a, b, areMutuallyExclusive) {\r\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\r\n\r\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\r\n  };\r\n\r\n  return PairSet;\r\n}();\r\n\r\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\r\n  var map = data[a];\r\n\r\n  if (!map) {\r\n    map = Object.create(null);\r\n    data[a] = map;\r\n  }\r\n\r\n  map[b] = areMutuallyExclusive;\r\n}"]},"metadata":{},"sourceType":"module"}