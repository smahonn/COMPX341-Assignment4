{"ast":null,"code":"var AWS = require('./core');\n/**\r\n * @api private\r\n * @!method on(eventName, callback)\r\n *   Registers an event listener callback for the event given by `eventName`.\r\n *   Parameters passed to the callback function depend on the individual event\r\n *   being triggered. See the event documentation for those parameters.\r\n *\r\n *   @param eventName [String] the event name to register the listener for\r\n *   @param callback [Function] the listener callback function\r\n *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\r\n *     Default to be false.\r\n *   @return [AWS.SequentialExecutor] the same object for chaining\r\n */\n\n\nAWS.SequentialExecutor = AWS.util.inherit({\n  constructor: function SequentialExecutor() {\n    this._events = {};\n  },\n\n  /**\r\n   * @api private\r\n   */\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n  on: function on(eventName, listener, toHead) {\n    if (this._events[eventName]) {\n      toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n\n    return this;\n  },\n  onAsync: function onAsync(eventName, listener, toHead) {\n    listener._isAsync = true;\n    return this.on(eventName, listener, toHead);\n  },\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n\n    return this;\n  },\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = function doneCallback() {};\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\n    var self = this;\n    var error = prevError || null;\n\n    function callNextListener(err) {\n      if (err) {\n        error = AWS.util.error(error || new Error(), err);\n\n        if (self._haltHandlersOnError) {\n          return doneCallback.call(self, error);\n        }\n      }\n\n      self.callListeners(listeners, args, doneCallback, error);\n    }\n\n    while (listeners.length > 0) {\n      var listener = listeners.shift();\n\n      if (listener._isAsync) {\n        // asynchronous listener\n        listener.apply(self, args.concat([callNextListener]));\n        return; // stop here, callNextListener will continue\n      } else {\n        // synchronous listener\n        try {\n          listener.apply(self, args);\n        } catch (err) {\n          error = AWS.util.error(error || new Error(), err);\n        }\n\n        if (error && self._haltHandlersOnError) {\n          doneCallback.call(self, error);\n          return;\n        }\n      }\n    }\n\n    doneCallback.call(self, error);\n  },\n\n  /**\r\n   * Adds or copies a set of listeners from another list of\r\n   * listeners or SequentialExecutor object.\r\n   *\r\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\r\n   *   a list of events and callbacks, or an event emitter object\r\n   *   containing listeners to add to this emitter object.\r\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\r\n   * @example Adding listeners from a map of listeners\r\n   *   emitter.addListeners({\r\n   *     event1: [function() { ... }, function() { ... }],\r\n   *     event2: [function() { ... }]\r\n   *   });\r\n   *   emitter.emit('event1'); // emitter has event1\r\n   *   emitter.emit('event2'); // emitter has event2\r\n   * @example Adding listeners from another emitter object\r\n   *   var emitter1 = new AWS.SequentialExecutor();\r\n   *   emitter1.on('event1', function() { ... });\r\n   *   emitter1.on('event2', function() { ... });\r\n   *   var emitter2 = new AWS.SequentialExecutor();\r\n   *   emitter2.addListeners(emitter1);\r\n   *   emitter2.emit('event1'); // emitter2 has event1\r\n   *   emitter2.emit('event2'); // emitter2 has event2\r\n   */\n  addListeners: function addListeners(listeners) {\n    var self = this; // extract listeners if parameter is an SequentialExecutor object\n\n    if (listeners._events) listeners = listeners._events;\n    AWS.util.each(listeners, function (event, callbacks) {\n      if (typeof callbacks === 'function') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function (callback) {\n        self.on(event, callback);\n      });\n    });\n    return self;\n  },\n\n  /**\r\n   * Registers an event with {on} and saves the callback handle function\r\n   * as a property on the emitter object using a given `name`.\r\n   *\r\n   * @param name [String] the property name to set on this object containing\r\n   *   the callback function handle so that the listener can be removed in\r\n   *   the future.\r\n   * @param (see on)\r\n   * @return (see on)\r\n   * @example Adding a named listener DATA_CALLBACK\r\n   *   var listener = function() { doSomething(); };\r\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\r\n   *\r\n   *   // the following prints: true\r\n   *   console.log(emitter.DATA_CALLBACK == listener);\r\n   */\n  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\n    this[name] = callback;\n    this.addListener(eventName, callback, toHead);\n    return this;\n  },\n\n  /**\r\n   * @api private\r\n   */\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback, toHead);\n  },\n\n  /**\r\n   * Helper method to add a set of named listeners using\r\n   * {addNamedListener}. The callback contains a parameter\r\n   * with a handle to the `addNamedListener` method.\r\n   *\r\n   * @callback callback function(add)\r\n   *   The callback function is called immediately in order to provide\r\n   *   the `add` function to the block. This simplifies the addition of\r\n   *   a large group of named listeners.\r\n   *   @param add [Function] the {addNamedListener} function to call\r\n   *     when registering listeners.\r\n   * @example Adding a set of named listeners\r\n   *   emitter.addNamedListeners(function(add) {\r\n   *     add('DATA_CALLBACK', 'data', function() { ... });\r\n   *     add('OTHER', 'otherEvent', function() { ... });\r\n   *     add('LAST', 'lastEvent', function() { ... });\r\n   *   });\r\n   *\r\n   *   // these properties are now set:\r\n   *   emitter.DATA_CALLBACK;\r\n   *   emitter.OTHER;\r\n   *   emitter.LAST;\r\n   */\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(function () {\n      self.addNamedListener.apply(self, arguments);\n    }, function () {\n      self.addNamedAsyncListener.apply(self, arguments);\n    });\n    return this;\n  }\n});\n/**\r\n * {on} is the prefered method.\r\n * @api private\r\n */\n\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n/**\r\n * @api private\r\n */\n\nmodule.exports = AWS.SequentialExecutor;","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/sequential_executor.js"],"names":["AWS","require","SequentialExecutor","util","inherit","constructor","_events","listeners","eventName","slice","on","listener","toHead","unshift","push","onAsync","_isAsync","removeListener","length","position","i","splice","removeAllListeners","emit","eventArgs","doneCallback","count","callListeners","args","prevError","self","error","callNextListener","err","Error","_haltHandlersOnError","call","shift","apply","concat","addListeners","each","event","callbacks","arrayEach","callback","addNamedListener","name","addListener","addNamedAsyncListener","addNamedListeners","arguments","prototype","module","exports"],"mappings":"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","sourcesContent":["var AWS = require('./core');\r\n\r\n/**\r\n * @api private\r\n * @!method on(eventName, callback)\r\n *   Registers an event listener callback for the event given by `eventName`.\r\n *   Parameters passed to the callback function depend on the individual event\r\n *   being triggered. See the event documentation for those parameters.\r\n *\r\n *   @param eventName [String] the event name to register the listener for\r\n *   @param callback [Function] the listener callback function\r\n *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\r\n *     Default to be false.\r\n *   @return [AWS.SequentialExecutor] the same object for chaining\r\n */\r\nAWS.SequentialExecutor = AWS.util.inherit({\r\n\r\n  constructor: function SequentialExecutor() {\r\n    this._events = {};\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  listeners: function listeners(eventName) {\r\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\r\n  },\r\n\r\n  on: function on(eventName, listener, toHead) {\r\n    if (this._events[eventName]) {\r\n      toHead ?\r\n        this._events[eventName].unshift(listener) :\r\n        this._events[eventName].push(listener);\r\n    } else {\r\n      this._events[eventName] = [listener];\r\n    }\r\n    return this;\r\n  },\r\n\r\n  onAsync: function onAsync(eventName, listener, toHead) {\r\n    listener._isAsync = true;\r\n    return this.on(eventName, listener, toHead);\r\n  },\r\n\r\n  removeListener: function removeListener(eventName, listener) {\r\n    var listeners = this._events[eventName];\r\n    if (listeners) {\r\n      var length = listeners.length;\r\n      var position = -1;\r\n      for (var i = 0; i < length; ++i) {\r\n        if (listeners[i] === listener) {\r\n          position = i;\r\n        }\r\n      }\r\n      if (position > -1) {\r\n        listeners.splice(position, 1);\r\n      }\r\n    }\r\n    return this;\r\n  },\r\n\r\n  removeAllListeners: function removeAllListeners(eventName) {\r\n    if (eventName) {\r\n      delete this._events[eventName];\r\n    } else {\r\n      this._events = {};\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  emit: function emit(eventName, eventArgs, doneCallback) {\r\n    if (!doneCallback) doneCallback = function() { };\r\n    var listeners = this.listeners(eventName);\r\n    var count = listeners.length;\r\n    this.callListeners(listeners, eventArgs, doneCallback);\r\n    return count > 0;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\r\n    var self = this;\r\n    var error = prevError || null;\r\n\r\n    function callNextListener(err) {\r\n      if (err) {\r\n        error = AWS.util.error(error || new Error(), err);\r\n        if (self._haltHandlersOnError) {\r\n          return doneCallback.call(self, error);\r\n        }\r\n      }\r\n      self.callListeners(listeners, args, doneCallback, error);\r\n    }\r\n\r\n    while (listeners.length > 0) {\r\n      var listener = listeners.shift();\r\n      if (listener._isAsync) { // asynchronous listener\r\n        listener.apply(self, args.concat([callNextListener]));\r\n        return; // stop here, callNextListener will continue\r\n      } else { // synchronous listener\r\n        try {\r\n          listener.apply(self, args);\r\n        } catch (err) {\r\n          error = AWS.util.error(error || new Error(), err);\r\n        }\r\n        if (error && self._haltHandlersOnError) {\r\n          doneCallback.call(self, error);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    doneCallback.call(self, error);\r\n  },\r\n\r\n  /**\r\n   * Adds or copies a set of listeners from another list of\r\n   * listeners or SequentialExecutor object.\r\n   *\r\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\r\n   *   a list of events and callbacks, or an event emitter object\r\n   *   containing listeners to add to this emitter object.\r\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\r\n   * @example Adding listeners from a map of listeners\r\n   *   emitter.addListeners({\r\n   *     event1: [function() { ... }, function() { ... }],\r\n   *     event2: [function() { ... }]\r\n   *   });\r\n   *   emitter.emit('event1'); // emitter has event1\r\n   *   emitter.emit('event2'); // emitter has event2\r\n   * @example Adding listeners from another emitter object\r\n   *   var emitter1 = new AWS.SequentialExecutor();\r\n   *   emitter1.on('event1', function() { ... });\r\n   *   emitter1.on('event2', function() { ... });\r\n   *   var emitter2 = new AWS.SequentialExecutor();\r\n   *   emitter2.addListeners(emitter1);\r\n   *   emitter2.emit('event1'); // emitter2 has event1\r\n   *   emitter2.emit('event2'); // emitter2 has event2\r\n   */\r\n  addListeners: function addListeners(listeners) {\r\n    var self = this;\r\n\r\n    // extract listeners if parameter is an SequentialExecutor object\r\n    if (listeners._events) listeners = listeners._events;\r\n\r\n    AWS.util.each(listeners, function(event, callbacks) {\r\n      if (typeof callbacks === 'function') callbacks = [callbacks];\r\n      AWS.util.arrayEach(callbacks, function(callback) {\r\n        self.on(event, callback);\r\n      });\r\n    });\r\n\r\n    return self;\r\n  },\r\n\r\n  /**\r\n   * Registers an event with {on} and saves the callback handle function\r\n   * as a property on the emitter object using a given `name`.\r\n   *\r\n   * @param name [String] the property name to set on this object containing\r\n   *   the callback function handle so that the listener can be removed in\r\n   *   the future.\r\n   * @param (see on)\r\n   * @return (see on)\r\n   * @example Adding a named listener DATA_CALLBACK\r\n   *   var listener = function() { doSomething(); };\r\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\r\n   *\r\n   *   // the following prints: true\r\n   *   console.log(emitter.DATA_CALLBACK == listener);\r\n   */\r\n  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\r\n    this[name] = callback;\r\n    this.addListener(eventName, callback, toHead);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {\r\n    callback._isAsync = true;\r\n    return this.addNamedListener(name, eventName, callback, toHead);\r\n  },\r\n\r\n  /**\r\n   * Helper method to add a set of named listeners using\r\n   * {addNamedListener}. The callback contains a parameter\r\n   * with a handle to the `addNamedListener` method.\r\n   *\r\n   * @callback callback function(add)\r\n   *   The callback function is called immediately in order to provide\r\n   *   the `add` function to the block. This simplifies the addition of\r\n   *   a large group of named listeners.\r\n   *   @param add [Function] the {addNamedListener} function to call\r\n   *     when registering listeners.\r\n   * @example Adding a set of named listeners\r\n   *   emitter.addNamedListeners(function(add) {\r\n   *     add('DATA_CALLBACK', 'data', function() { ... });\r\n   *     add('OTHER', 'otherEvent', function() { ... });\r\n   *     add('LAST', 'lastEvent', function() { ... });\r\n   *   });\r\n   *\r\n   *   // these properties are now set:\r\n   *   emitter.DATA_CALLBACK;\r\n   *   emitter.OTHER;\r\n   *   emitter.LAST;\r\n   */\r\n  addNamedListeners: function addNamedListeners(callback) {\r\n    var self = this;\r\n    callback(\r\n      function() {\r\n        self.addNamedListener.apply(self, arguments);\r\n      },\r\n      function() {\r\n        self.addNamedAsyncListener.apply(self, arguments);\r\n      }\r\n    );\r\n    return this;\r\n  }\r\n});\r\n\r\n/**\r\n * {on} is the prefered method.\r\n * @api private\r\n */\r\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = AWS.SequentialExecutor;\r\n"]},"metadata":{},"sourceType":"script"}