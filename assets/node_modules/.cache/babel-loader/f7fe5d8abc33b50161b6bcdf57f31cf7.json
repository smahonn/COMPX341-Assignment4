{"ast":null,"code":"var hashUtils = require('./browserHashUtils');\n/**\r\n * @api private\r\n */\n\n\nfunction Hmac(hashCtor, secret) {\n  this.hash = new hashCtor();\n  this.outer = new hashCtor();\n  var inner = bufferFromSecret(hashCtor, secret);\n  var outer = new Uint8Array(hashCtor.BLOCK_SIZE);\n  outer.set(inner);\n\n  for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {\n    inner[i] ^= 0x36;\n    outer[i] ^= 0x5c;\n  }\n\n  this.hash.update(inner);\n  this.outer.update(outer); // Zero out the copied key buffer.\n\n  for (var i = 0; i < inner.byteLength; i++) {\n    inner[i] = 0;\n  }\n}\n/**\r\n * @api private\r\n */\n\n\nmodule.exports = exports = Hmac;\n\nHmac.prototype.update = function (toHash) {\n  if (hashUtils.isEmptyData(toHash) || this.error) {\n    return this;\n  }\n\n  try {\n    this.hash.update(hashUtils.convertToBuffer(toHash));\n  } catch (e) {\n    this.error = e;\n  }\n\n  return this;\n};\n\nHmac.prototype.digest = function (encoding) {\n  if (!this.outer.finished) {\n    this.outer.update(this.hash.digest());\n  }\n\n  return this.outer.digest(encoding);\n};\n\nfunction bufferFromSecret(hashCtor, secret) {\n  var input = hashUtils.convertToBuffer(secret);\n\n  if (input.byteLength > hashCtor.BLOCK_SIZE) {\n    var bufferHash = new hashCtor();\n    bufferHash.update(input);\n    input = bufferHash.digest();\n  }\n\n  var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\n  buffer.set(input);\n  return buffer;\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/browserHmac.js"],"names":["hashUtils","require","Hmac","hashCtor","secret","hash","outer","inner","bufferFromSecret","Uint8Array","BLOCK_SIZE","set","i","update","byteLength","module","exports","prototype","toHash","isEmptyData","error","convertToBuffer","e","digest","encoding","finished","input","bufferHash","buffer"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAvB;AAEA;AACA;AACA;;;AACA,SAASC,IAAT,CAAcC,QAAd,EAAwBC,MAAxB,EAAgC;AAC5B,OAAKC,IAAL,GAAY,IAAIF,QAAJ,EAAZ;AACA,OAAKG,KAAL,GAAa,IAAIH,QAAJ,EAAb;AAEA,MAAII,KAAK,GAAGC,gBAAgB,CAACL,QAAD,EAAWC,MAAX,CAA5B;AACA,MAAIE,KAAK,GAAG,IAAIG,UAAJ,CAAeN,QAAQ,CAACO,UAAxB,CAAZ;AACAJ,EAAAA,KAAK,CAACK,GAAN,CAAUJ,KAAV;;AAEA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,QAAQ,CAACO,UAA7B,EAAyCE,CAAC,EAA1C,EAA8C;AAC1CL,IAAAA,KAAK,CAACK,CAAD,CAAL,IAAY,IAAZ;AACAN,IAAAA,KAAK,CAACM,CAAD,CAAL,IAAY,IAAZ;AACH;;AAED,OAAKP,IAAL,CAAUQ,MAAV,CAAiBN,KAAjB;AACA,OAAKD,KAAL,CAAWO,MAAX,CAAkBP,KAAlB,EAd4B,CAgB5B;;AACA,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACO,UAA1B,EAAsCF,CAAC,EAAvC,EAA2C;AACvCL,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAW,CAAX;AACH;AACJ;AAED;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGd,IAA3B;;AAEAA,IAAI,CAACe,SAAL,CAAeJ,MAAf,GAAwB,UAAUK,MAAV,EAAkB;AACtC,MAAIlB,SAAS,CAACmB,WAAV,CAAsBD,MAAtB,KAAiC,KAAKE,KAA1C,EAAiD;AAC7C,WAAO,IAAP;AACH;;AAED,MAAI;AACA,SAAKf,IAAL,CAAUQ,MAAV,CAAiBb,SAAS,CAACqB,eAAV,CAA0BH,MAA1B,CAAjB;AACH,GAFD,CAEE,OAAOI,CAAP,EAAU;AACR,SAAKF,KAAL,GAAaE,CAAb;AACH;;AAED,SAAO,IAAP;AACH,CAZD;;AAcApB,IAAI,CAACe,SAAL,CAAeM,MAAf,GAAwB,UAAUC,QAAV,EAAoB;AACxC,MAAI,CAAC,KAAKlB,KAAL,CAAWmB,QAAhB,EAA0B;AACtB,SAAKnB,KAAL,CAAWO,MAAX,CAAkB,KAAKR,IAAL,CAAUkB,MAAV,EAAlB;AACH;;AAED,SAAO,KAAKjB,KAAL,CAAWiB,MAAX,CAAkBC,QAAlB,CAAP;AACH,CAND;;AAQA,SAAShB,gBAAT,CAA0BL,QAA1B,EAAoCC,MAApC,EAA4C;AACxC,MAAIsB,KAAK,GAAG1B,SAAS,CAACqB,eAAV,CAA0BjB,MAA1B,CAAZ;;AACA,MAAIsB,KAAK,CAACZ,UAAN,GAAmBX,QAAQ,CAACO,UAAhC,EAA4C;AACxC,QAAIiB,UAAU,GAAG,IAAIxB,QAAJ,EAAjB;AACAwB,IAAAA,UAAU,CAACd,MAAX,CAAkBa,KAAlB;AACAA,IAAAA,KAAK,GAAGC,UAAU,CAACJ,MAAX,EAAR;AACH;;AACD,MAAIK,MAAM,GAAG,IAAInB,UAAJ,CAAeN,QAAQ,CAACO,UAAxB,CAAb;AACAkB,EAAAA,MAAM,CAACjB,GAAP,CAAWe,KAAX;AACA,SAAOE,MAAP;AACH","sourcesContent":["var hashUtils = require('./browserHashUtils');\r\n\r\n/**\r\n * @api private\r\n */\r\nfunction Hmac(hashCtor, secret) {\r\n    this.hash = new hashCtor();\r\n    this.outer = new hashCtor();\r\n\r\n    var inner = bufferFromSecret(hashCtor, secret);\r\n    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);\r\n    outer.set(inner);\r\n\r\n    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {\r\n        inner[i] ^= 0x36;\r\n        outer[i] ^= 0x5c;\r\n    }\r\n\r\n    this.hash.update(inner);\r\n    this.outer.update(outer);\r\n\r\n    // Zero out the copied key buffer.\r\n    for (var i = 0; i < inner.byteLength; i++) {\r\n        inner[i] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = exports = Hmac;\r\n\r\nHmac.prototype.update = function (toHash) {\r\n    if (hashUtils.isEmptyData(toHash) || this.error) {\r\n        return this;\r\n    }\r\n\r\n    try {\r\n        this.hash.update(hashUtils.convertToBuffer(toHash));\r\n    } catch (e) {\r\n        this.error = e;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nHmac.prototype.digest = function (encoding) {\r\n    if (!this.outer.finished) {\r\n        this.outer.update(this.hash.digest());\r\n    }\r\n\r\n    return this.outer.digest(encoding);\r\n};\r\n\r\nfunction bufferFromSecret(hashCtor, secret) {\r\n    var input = hashUtils.convertToBuffer(secret);\r\n    if (input.byteLength > hashCtor.BLOCK_SIZE) {\r\n        var bufferHash = new hashCtor;\r\n        bufferHash.update(input);\r\n        input = bufferHash.digest();\r\n    }\r\n    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\r\n    buffer.set(input);\r\n    return buffer;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}