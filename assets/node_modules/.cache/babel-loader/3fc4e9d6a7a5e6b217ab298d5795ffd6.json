{"ast":null,"code":"/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\nimport inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\r\n * Possible fragment spread\r\n *\r\n * A fragment spread is only valid if the type condition could ever possibly\r\n * be true: if there is a non-empty intersection of the possible parent types,\r\n * and possible types which pass the type condition.\r\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/@aws-amplify/api/node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs"],"names":["inspect","GraphQLError","doTypesOverlap","typeFromAST","isCompositeType","typeIncompatibleSpreadMessage","fragName","parentType","fragType","concat","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,OAAP,MAAoB,uBAApB;AACA,SAASC,YAAT,QAA6B,0BAA7B;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,OAAO,SAASC,6BAAT,CAAuCC,QAAvC,EAAiDC,UAAjD,EAA6DC,QAA7D,EAAuE;AAC5E,SAAO,cAAcC,MAAd,CAAqBH,QAArB,EAA+B,yCAA/B,IAA4E,UAAUG,MAAV,CAAiBF,UAAjB,EAA6B,4BAA7B,EAA2DE,MAA3D,CAAkED,QAAlE,EAA4E,KAA5E,CAAnF;AACD;AACD,OAAO,SAASE,iCAAT,CAA2CH,UAA3C,EAAuDC,QAAvD,EAAiE;AACtE,SAAO,kDAAkD,UAAUC,MAAV,CAAiBF,UAAjB,EAA6B,4BAA7B,EAA2DE,MAA3D,CAAkED,QAAlE,EAA4E,KAA5E,CAAzD;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,uBAAT,CAAiCC,OAAjC,EAA0C;AAC/C,SAAO;AACLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AAC5C,UAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAR,EAAf;AACA,UAAIR,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAIZ,eAAe,CAACI,QAAD,CAAf,IAA6BJ,eAAe,CAACG,UAAD,CAA5C,IAA4D,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA/E,EAA4H;AAC1HK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBS,iCAAiC,CAACV,OAAO,CAACO,UAAD,CAAR,EAAsBP,OAAO,CAACQ,QAAD,CAA7B,CAAlD,EAA4F,CAACM,IAAD,CAA5F,CAApB;AACD;AACF,KARI;AASLK,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBL,IAAxB,EAA8B;AAC5C,UAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAL,CAAUC,KAAzB;AACA,UAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAD,EAAUN,QAAV,CAA9B;AACA,UAAIC,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAIR,QAAQ,IAAID,UAAZ,IAA0B,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA7C,EAA0F;AACxFK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBI,6BAA6B,CAACC,QAAD,EAAWN,OAAO,CAACO,UAAD,CAAlB,EAAgCP,OAAO,CAACQ,QAAD,CAAvC,CAA9C,EAAkG,CAACM,IAAD,CAAlG,CAApB;AACD;AACF;AAjBI,GAAP;AAmBD;;AAED,SAASQ,eAAT,CAAyBV,OAAzB,EAAkCQ,IAAlC,EAAwC;AACtC,MAAIG,IAAI,GAAGX,OAAO,CAACY,WAAR,CAAoBJ,IAApB,CAAX;;AAEA,MAAIG,IAAJ,EAAU;AACR,QAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAR,EAAD,EAAsBM,IAAI,CAACG,aAA3B,CAAtB;;AAEA,QAAItB,eAAe,CAACqB,IAAD,CAAnB,EAA2B;AACzB,aAAOA,IAAP;AACD;AACF;AACF","sourcesContent":["/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\r\nimport inspect from '../../jsutils/inspect';\r\nimport { GraphQLError } from '../../error/GraphQLError';\r\nimport { doTypesOverlap } from '../../utilities/typeComparators';\r\nimport { typeFromAST } from '../../utilities/typeFromAST';\r\nimport { isCompositeType } from '../../type/definition';\r\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\r\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\r\n}\r\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\r\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\r\n}\r\n/**\r\n * Possible fragment spread\r\n *\r\n * A fragment spread is only valid if the type condition could ever possibly\r\n * be true: if there is a non-empty intersection of the possible parent types,\r\n * and possible types which pass the type condition.\r\n */\r\n\r\nexport function PossibleFragmentSpreads(context) {\r\n  return {\r\n    InlineFragment: function InlineFragment(node) {\r\n      var fragType = context.getType();\r\n      var parentType = context.getParentType();\r\n\r\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\r\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\r\n      }\r\n    },\r\n    FragmentSpread: function FragmentSpread(node) {\r\n      var fragName = node.name.value;\r\n      var fragType = getFragmentType(context, fragName);\r\n      var parentType = context.getParentType();\r\n\r\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\r\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction getFragmentType(context, name) {\r\n  var frag = context.getFragment(name);\r\n\r\n  if (frag) {\r\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\r\n\r\n    if (isCompositeType(type)) {\r\n      return type;\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}