{"ast":null,"code":"/**\r\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\r\n */\nimport closest from './closest';\nimport matches from './matches';\n/**\r\n * Delegates the handling of events for an element matching a selector to an\r\n * ancestor of the matching element.\r\n * @param {!Node} ancestor The ancestor element to add the listener to.\r\n * @param {string} eventType The event type to listen to.\r\n * @param {string} selector A CSS selector to match against child elements.\r\n * @param {!Function} callback A function to run any time the event happens.\r\n * @param {Object=} opts A configuration options object. The available options:\r\n *     - useCapture<boolean>: If true, bind to the event capture phase.\r\n *     - deep<boolean>: If true, delegate into shadow trees.\r\n * @return {Object} The delegate object. It contains a destroy method.\r\n */\n\nexport default function delegate(ancestor, eventType, selector, callback, opts) {\n  if (opts === void 0) {\n    opts = {};\n  } // Defines the event listener.\n\n\n  var listener = function listener(event) {\n    var delegateTarget; // If opts.composed is true and the event originated from inside a Shadow\n    // tree, check the composed path nodes.\n\n    if (opts['composed'] && typeof event['composedPath'] === 'function') {\n      var composedPath = event.composedPath();\n\n      for (var i = 0, node = void 0; node = composedPath[i]; i++) {\n        if (node.nodeType === 1 && matches(node, selector)) {\n          delegateTarget = node;\n        }\n      }\n    } else {\n      // Otherwise check the parents.\n      delegateTarget = closest(event.target, selector, true);\n    }\n\n    if (delegateTarget) {\n      callback.call(delegateTarget, event, delegateTarget);\n    }\n  };\n\n  ancestor.addEventListener(eventType, listener, opts['useCapture']);\n  return {\n    destroy: function destroy() {\n      ancestor.removeEventListener(eventType, listener, opts['useCapture']);\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/vendor/dom-utils/delegate.ts"],"names":[],"mappings":"AAAA;;AAEG;AAEH,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,OAAP,MAAoB,WAApB;AAEA;;;;;;;;;;;AAWG;;AACH,eAAc,SAAU,QAAV,CACb,QADa,EAEb,SAFa,EAGb,QAHa,EAIb,QAJa,EAKb,IALa,EAKJ;AAAT,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,EAAA;AAAS,GAAA,CAET;;;AACA,MAAM,QAAQ,GAAG,SAAX,QAAW,CAAS,KAAT,EAAc;AAC9B,QAAI,cAAJ,CAD8B,CAG9B;AACA;;AACA,QAAI,IAAI,CAAC,UAAD,CAAJ,IAAoB,OAAO,KAAK,CAAC,cAAD,CAAZ,KAAiC,UAAzD,EAAqE;AACpE,UAAM,YAAY,GAAG,KAAK,CAAC,YAAN,EAArB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,IAAI,GAAA,KAAA,CAApB,EAAuB,IAAI,GAAG,YAAY,CAAC,CAAD,CAA1C,EAAgD,CAAC,EAAjD,EAAqD;AACpD,YAAI,IAAI,CAAC,QAAL,KAAkB,CAAlB,IAAuB,OAAO,CAAC,IAAD,EAAO,QAAP,CAAlC,EAAoD;AACnD,UAAA,cAAc,GAAG,IAAjB;AACA;AACD;AACD,KAPD,MAOO;AACN;AACA,MAAA,cAAc,GAAG,OAAO,CAAC,KAAK,CAAC,MAAP,EAAe,QAAf,EAAyB,IAAzB,CAAxB;AACA;;AAED,QAAI,cAAJ,EAAoB;AACnB,MAAA,QAAQ,CAAC,IAAT,CAAc,cAAd,EAA8B,KAA9B,EAAqC,cAArC;AACA;AACD,GApBD;;AAsBA,EAAA,QAAQ,CAAC,gBAAT,CAA0B,SAA1B,EAAqC,QAArC,EAA+C,IAAI,CAAC,YAAD,CAAnD;AAEA,SAAO;AACN,IAAA,OAAO,EAAE,mBAAA;AACR,MAAA,QAAQ,CAAC,mBAAT,CAA6B,SAA7B,EAAwC,QAAxC,EAAkD,IAAI,CAAC,YAAD,CAAtD;AACA;AAHK,GAAP;AAKA","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\r\n */\r\nimport closest from './closest';\r\nimport matches from './matches';\r\n/**\r\n * Delegates the handling of events for an element matching a selector to an\r\n * ancestor of the matching element.\r\n * @param {!Node} ancestor The ancestor element to add the listener to.\r\n * @param {string} eventType The event type to listen to.\r\n * @param {string} selector A CSS selector to match against child elements.\r\n * @param {!Function} callback A function to run any time the event happens.\r\n * @param {Object=} opts A configuration options object. The available options:\r\n *     - useCapture<boolean>: If true, bind to the event capture phase.\r\n *     - deep<boolean>: If true, delegate into shadow trees.\r\n * @return {Object} The delegate object. It contains a destroy method.\r\n */\r\nexport default function delegate(ancestor, eventType, selector, callback, opts) {\r\n    if (opts === void 0) { opts = {}; }\r\n    // Defines the event listener.\r\n    var listener = function (event) {\r\n        var delegateTarget;\r\n        // If opts.composed is true and the event originated from inside a Shadow\r\n        // tree, check the composed path nodes.\r\n        if (opts['composed'] && typeof event['composedPath'] === 'function') {\r\n            var composedPath = event.composedPath();\r\n            for (var i = 0, node = void 0; (node = composedPath[i]); i++) {\r\n                if (node.nodeType === 1 && matches(node, selector)) {\r\n                    delegateTarget = node;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Otherwise check the parents.\r\n            delegateTarget = closest(event.target, selector, true);\r\n        }\r\n        if (delegateTarget) {\r\n            callback.call(delegateTarget, event, delegateTarget);\r\n        }\r\n    };\r\n    ancestor.addEventListener(eventType, listener, opts['useCapture']);\r\n    return {\r\n        destroy: function () {\r\n            ancestor.removeEventListener(eventType, listener, opts['useCapture']);\r\n        },\r\n    };\r\n}\r\n//# sourceMappingURL=delegate.js.map"]},"metadata":{},"sourceType":"module"}