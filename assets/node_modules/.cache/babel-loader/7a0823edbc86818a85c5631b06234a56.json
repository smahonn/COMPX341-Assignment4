{"ast":null,"code":"var util = require('../core').util;\n\nvar toBuffer = util.buffer.toBuffer; // All prelude components are unsigned, 32-bit integers\n\nvar PRELUDE_MEMBER_LENGTH = 4; // The prelude consists of two components\n\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2; // Checksums are always CRC32 hashes.\n\nvar CHECKSUM_LENGTH = 4; // Messages must include a full prelude, a prelude checksum, and a message checksum\n\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n/**\r\n * @api private\r\n *\r\n * @param {Buffer} message\r\n */\n\nfunction splitMessage(message) {\n  if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\n\n  if (message.length < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error('Provided message too short to accommodate event stream message overhead');\n  }\n\n  if (message.length !== message.readUInt32BE(0)) {\n    throw new Error('Reported message length does not match received message length');\n  }\n\n  var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\n\n  if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {\n    throw new Error('The prelude checksum specified in the message (' + expectedPreludeChecksum + ') does not match the calculated CRC32 checksum.');\n  }\n\n  var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\n\n  if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {\n    throw new Error('The message checksum did not match the expected value of ' + expectedMessageChecksum);\n  }\n\n  var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\n  var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\n  return {\n    headers: message.slice(headersStart, headersEnd),\n    body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)\n  };\n}\n/**\r\n * @api private\r\n */\n\n\nmodule.exports = {\n  splitMessage: splitMessage\n};","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/aws-sdk/lib/event-stream/split-message.js"],"names":["util","require","toBuffer","buffer","PRELUDE_MEMBER_LENGTH","PRELUDE_LENGTH","CHECKSUM_LENGTH","MINIMUM_MESSAGE_LENGTH","splitMessage","message","Buffer","isBuffer","length","Error","readUInt32BE","expectedPreludeChecksum","crypto","crc32","slice","expectedMessageChecksum","headersStart","headersEnd","headers","body","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,IAA9B;;AACA,IAAIE,QAAQ,GAAGF,IAAI,CAACG,MAAL,CAAYD,QAA3B,C,CAEA;;AACA,IAAIE,qBAAqB,GAAG,CAA5B,C,CACA;;AACA,IAAIC,cAAc,GAAGD,qBAAqB,GAAG,CAA7C,C,CACA;;AACA,IAAIE,eAAe,GAAG,CAAtB,C,CACA;;AACA,IAAIC,sBAAsB,GAAGF,cAAc,GAAGC,eAAe,GAAG,CAAhE;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASE,YAAT,CAAsBC,OAAtB,EAA+B;AAC3B,MAAI,CAACT,IAAI,CAACU,MAAL,CAAYC,QAAZ,CAAqBF,OAArB,CAAL,EAAoCA,OAAO,GAAGP,QAAQ,CAACO,OAAD,CAAlB;;AAEpC,MAAIA,OAAO,CAACG,MAAR,GAAiBL,sBAArB,EAA6C;AACzC,UAAM,IAAIM,KAAJ,CAAU,yEAAV,CAAN;AACH;;AAED,MAAIJ,OAAO,CAACG,MAAR,KAAmBH,OAAO,CAACK,YAAR,CAAqB,CAArB,CAAvB,EAAgD;AAC5C,UAAM,IAAID,KAAJ,CAAU,gEAAV,CAAN;AACH;;AAED,MAAIE,uBAAuB,GAAGN,OAAO,CAACK,YAAR,CAAqBT,cAArB,CAA9B;;AAEA,MACIU,uBAAuB,KAAKf,IAAI,CAACgB,MAAL,CAAYC,KAAZ,CACxBR,OAAO,CAACS,KAAR,CAAc,CAAd,EAAiBb,cAAjB,CADwB,CADhC,EAIE;AACE,UAAM,IAAIQ,KAAJ,CACF,oDACAE,uBADA,GAEA,iDAHE,CAAN;AAKH;;AAED,MAAII,uBAAuB,GAAGV,OAAO,CAACK,YAAR,CAAqBL,OAAO,CAACG,MAAR,GAAiBN,eAAtC,CAA9B;;AAEA,MACIa,uBAAuB,KAAKnB,IAAI,CAACgB,MAAL,CAAYC,KAAZ,CACxBR,OAAO,CAACS,KAAR,CAAc,CAAd,EAAiBT,OAAO,CAACG,MAAR,GAAiBN,eAAlC,CADwB,CADhC,EAIE;AACE,UAAM,IAAIO,KAAJ,CACF,8DACIM,uBAFF,CAAN;AAIH;;AAED,MAAIC,YAAY,GAAGf,cAAc,GAAGC,eAApC;AACA,MAAIe,UAAU,GAAGD,YAAY,GAAGX,OAAO,CAACK,YAAR,CAAqBV,qBAArB,CAAhC;AAEA,SAAO;AACHkB,IAAAA,OAAO,EAAEb,OAAO,CAACS,KAAR,CAAcE,YAAd,EAA4BC,UAA5B,CADN;AAEHE,IAAAA,IAAI,EAAEd,OAAO,CAACS,KAAR,CAAcG,UAAd,EAA0BZ,OAAO,CAACG,MAAR,GAAiBN,eAA3C;AAFH,GAAP;AAIH;AAED;AACA;AACA;;;AACAkB,MAAM,CAACC,OAAP,GAAiB;AACbjB,EAAAA,YAAY,EAAEA;AADD,CAAjB","sourcesContent":["var util = require('../core').util;\r\nvar toBuffer = util.buffer.toBuffer;\r\n\r\n// All prelude components are unsigned, 32-bit integers\r\nvar PRELUDE_MEMBER_LENGTH = 4;\r\n// The prelude consists of two components\r\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\r\n// Checksums are always CRC32 hashes.\r\nvar CHECKSUM_LENGTH = 4;\r\n// Messages must include a full prelude, a prelude checksum, and a message checksum\r\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\r\n\r\n/**\r\n * @api private\r\n *\r\n * @param {Buffer} message\r\n */\r\nfunction splitMessage(message) {\r\n    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\r\n\r\n    if (message.length < MINIMUM_MESSAGE_LENGTH) {\r\n        throw new Error('Provided message too short to accommodate event stream message overhead');\r\n    }\r\n\r\n    if (message.length !== message.readUInt32BE(0)) {\r\n        throw new Error('Reported message length does not match received message length');\r\n    }\r\n\r\n    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\r\n\r\n    if (\r\n        expectedPreludeChecksum !== util.crypto.crc32(\r\n            message.slice(0, PRELUDE_LENGTH)\r\n        )\r\n    ) {\r\n        throw new Error(\r\n            'The prelude checksum specified in the message (' +\r\n            expectedPreludeChecksum +\r\n            ') does not match the calculated CRC32 checksum.'\r\n        );\r\n    }\r\n\r\n    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\r\n\r\n    if (\r\n        expectedMessageChecksum !== util.crypto.crc32(\r\n            message.slice(0, message.length - CHECKSUM_LENGTH)\r\n        )\r\n    ) {\r\n        throw new Error(\r\n            'The message checksum did not match the expected value of ' +\r\n                expectedMessageChecksum\r\n        );\r\n    }\r\n\r\n    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\r\n    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\r\n\r\n    return {\r\n        headers: message.slice(headersStart, headersEnd),\r\n        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),\r\n    };\r\n}\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = {\r\n    splitMessage: splitMessage\r\n};\r\n"]},"metadata":{},"sourceType":"script"}