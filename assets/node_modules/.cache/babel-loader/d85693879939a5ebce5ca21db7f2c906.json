{"ast":null,"code":"/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at \") + 'this location.';\n}\n/**\r\n * Unique directive names per location\r\n *\r\n * A GraphQL document is only valid if all directives at a given location\r\n * are uniquely named.\r\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var directive = _step.value;\n            var directiveName = directive.name.value;\n\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));\n            } else {\n              knownDirectives[directiveName] = directive;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/Shutt/Documents/COMPX341/COMPX341-Assignment4/assets/node_modules/@aws-amplify/api/node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs"],"names":["GraphQLError","duplicateDirectiveMessage","directiveName","concat","UniqueDirectivesPerLocation","context","enter","node","directives","knownDirectives","Object","create","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","directive","value","name","reportError","err","return"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAT,QAA6B,0BAA7B;AACA,OAAO,SAASC,yBAAT,CAAmCC,aAAnC,EAAkD;AACvD,SAAO,mBAAmBC,MAAnB,CAA0BD,aAA1B,EAAyC,8BAAzC,IAA2E,gBAAlF;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,2BAAT,CAAqCC,OAArC,EAA8C;AACnD,SAAO;AACL;AACA;AACA;AACAC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,IAAf,EAAqB;AAC1B;AACA,UAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;;AAEA,UAAIA,UAAJ,EAAgB;AACd,YAAIC,eAAe,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtB;AACA,YAAIC,yBAAyB,GAAG,IAAhC;AACA,YAAIC,iBAAiB,GAAG,KAAxB;AACA,YAAIC,cAAc,GAAGC,SAArB;;AAEA,YAAI;AACF,eAAK,IAAIC,SAAS,GAAGR,UAAU,CAACS,MAAM,CAACC,QAAR,CAAV,EAAhB,EAA+CC,KAApD,EAA2D,EAAEP,yBAAyB,GAAG,CAACO,KAAK,GAAGH,SAAS,CAACI,IAAV,EAAT,EAA2BC,IAAzD,CAA3D,EAA2HT,yBAAyB,GAAG,IAAvJ,EAA6J;AAC3J,gBAAIU,SAAS,GAAGH,KAAK,CAACI,KAAtB;AACA,gBAAIrB,aAAa,GAAGoB,SAAS,CAACE,IAAV,CAAeD,KAAnC;;AAEA,gBAAId,eAAe,CAACP,aAAD,CAAnB,EAAoC;AAClCG,cAAAA,OAAO,CAACoB,WAAR,CAAoB,IAAIzB,YAAJ,CAAiBC,yBAAyB,CAACC,aAAD,CAA1C,EAA2D,CAACO,eAAe,CAACP,aAAD,CAAhB,EAAiCoB,SAAjC,CAA3D,CAApB;AACD,aAFD,MAEO;AACLb,cAAAA,eAAe,CAACP,aAAD,CAAf,GAAiCoB,SAAjC;AACD;AACF;AACF,SAXD,CAWE,OAAOI,GAAP,EAAY;AACZb,UAAAA,iBAAiB,GAAG,IAApB;AACAC,UAAAA,cAAc,GAAGY,GAAjB;AACD,SAdD,SAcU;AACR,cAAI;AACF,gBAAI,CAACd,yBAAD,IAA8BI,SAAS,CAACW,MAAV,IAAoB,IAAtD,EAA4D;AAC1DX,cAAAA,SAAS,CAACW,MAAV;AACD;AACF,WAJD,SAIU;AACR,gBAAId,iBAAJ,EAAuB;AACrB,oBAAMC,cAAN;AACD;AACF;AACF;AACF;AACF;AAxCI,GAAP;AA0CD","sourcesContent":["/**\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *  strict\r\n */\r\nimport { GraphQLError } from '../../error/GraphQLError';\r\nexport function duplicateDirectiveMessage(directiveName) {\r\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at \") + 'this location.';\r\n}\r\n/**\r\n * Unique directive names per location\r\n *\r\n * A GraphQL document is only valid if all directives at a given location\r\n * are uniquely named.\r\n */\r\n\r\nexport function UniqueDirectivesPerLocation(context) {\r\n  return {\r\n    // Many different AST nodes may contain directives. Rather than listing\r\n    // them all, just listen for entering any node, and check to see if it\r\n    // defines any directives.\r\n    enter: function enter(node) {\r\n      // Flow can't refine that node.directives will only contain directives,\r\n      var directives = node.directives;\r\n\r\n      if (directives) {\r\n        var knownDirectives = Object.create(null);\r\n        var _iteratorNormalCompletion = true;\r\n        var _didIteratorError = false;\r\n        var _iteratorError = undefined;\r\n\r\n        try {\r\n          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\r\n            var directive = _step.value;\r\n            var directiveName = directive.name.value;\r\n\r\n            if (knownDirectives[directiveName]) {\r\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));\r\n            } else {\r\n              knownDirectives[directiveName] = directive;\r\n            }\r\n          }\r\n        } catch (err) {\r\n          _didIteratorError = true;\r\n          _iteratorError = err;\r\n        } finally {\r\n          try {\r\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\r\n              _iterator.return();\r\n            }\r\n          } finally {\r\n            if (_didIteratorError) {\r\n              throw _iteratorError;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}